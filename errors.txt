ipybox on ÓÇ† main via üêç 3.13.11 on üê≥ v28.1.1 via ipybox
‚ûú pytest -s tests/integration/test_code_exec.py
=================================================================================================== test session starts ===================================================================================================
platform darwin -- Python 3.13.11, pytest-8.4.2, pluggy-1.6.0
rootdir: /Users/martin/Development/gradion/ipybox
configfile: pyproject.toml
plugins: anyio-4.11.0, flaky-3.8.1, cov-4.1.0, asyncio-1.3.0, typeguard-4.4.4
asyncio: mode=Mode.STRICT, debug=False, asyncio_default_fixture_loop_scope=None, asyncio_default_test_loop_scope=function
collected 15 items

tests/integration/test_code_exec.py .[C 2026-02-05 08:16:01.431 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:03.448 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:05.487 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:08.819 KernelGatewayApp] received signal 15, stopping
F[IPKernelApp] ERROR | Exception in message handler:
Traceback (most recent call last):
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/ipykernel/kernelbase.py", line 471, in dispatch_shell
    await result
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/ipykernel/ipkernel.py", line 366, in execute_request
    await super().execute_request(stream, ident, parent)
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/ipykernel/kernelbase.py", line 850, in execute_request
    reply_msg: dict[str, t.Any] = self.session.send(  # type:ignore[assignment]
                                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        stream,
        ^^^^^^^
    ...<4 lines>...
        ident=ident,
        ^^^^^^^^^^^^
    )
    ^
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/jupyter_client/session.py", line 863, in send
    stream.send_multipart(to_send, copy=copy)
    ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/zmq/sugar/socket.py", line 749, in send_multipart
    self.send(msg, zmq.SNDMORE | flags, copy=copy, track=track)
    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/zmq/sugar/socket.py", line 698, in send
    return super().send(data, flags=flags, copy=copy, track=track)
           ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "zmq/backend/cython/_zmq.py", line 1152, in zmq.backend.cython._zmq.Socket.send
    def send(self, data, flags=0, copy: bint = True, track: bint = False):
    ^^^^^^^
  File "zmq/backend/cython/_zmq.py", line 1194, in zmq.backend.cython._zmq.Socket.send
    _check_closed(self)
    ^^^
  File "zmq/backend/cython/_zmq.py", line 1339, in zmq.backend.cython._zmq._check_closed
    raise ZMQError(ENOTSOCK)
    ^^^
zmq.error.ZMQError: Socket operation on non-socket
[C 2026-02-05 08:16:11.527 KernelGatewayApp] received signal 15, stopping
.[IPKernelApp] ERROR | Exception in message handler:
Traceback (most recent call last):
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/ipykernel/kernelbase.py", line 471, in dispatch_shell
    await result
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/ipykernel/ipkernel.py", line 366, in execute_request
    await super().execute_request(stream, ident, parent)
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/ipykernel/kernelbase.py", line 850, in execute_request
    reply_msg: dict[str, t.Any] = self.session.send(  # type:ignore[assignment]
                                  ~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^
        stream,
        ^^^^^^^
    ...<4 lines>...
        ident=ident,
        ^^^^^^^^^^^^
    )
    ^
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/jupyter_client/session.py", line 863, in send
    stream.send_multipart(to_send, copy=copy)
    ~~~~~~~~~~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/zmq/sugar/socket.py", line 749, in send_multipart
    self.send(msg, zmq.SNDMORE | flags, copy=copy, track=track)
    ~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "/Users/martin/Development/gradion/ipybox/.venv/lib/python3.13/site-packages/zmq/sugar/socket.py", line 698, in send
    return super().send(data, flags=flags, copy=copy, track=track)
           ~~~~~~~~~~~~^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
  File "zmq/backend/cython/_zmq.py", line 1152, in zmq.backend.cython._zmq.Socket.send
    def send(self, data, flags=0, copy: bint = True, track: bint = False):
    ^^^^^^^
  File "zmq/backend/cython/_zmq.py", line 1194, in zmq.backend.cython._zmq.Socket.send
    _check_closed(self)
    ^^^
  File "zmq/backend/cython/_zmq.py", line 1339, in zmq.backend.cython._zmq._check_closed
    raise ZMQError(ENOTSOCK)
    ^^^
zmq.error.ZMQError: Socket operation on non-socket
[C 2026-02-05 08:16:13.736 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:17.180 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:20.216 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:23.543 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:26.974 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:30.399 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:34.070 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:37.456 KernelGatewayApp] received signal 15, stopping
.[C 2026-02-05 08:16:40.034 KernelGatewayApp] received signal 15, stopping
[W 260205 08:16:41 websocket:1327] The websocket_ping_timeout (90000) cannot be longer than the websocket_ping_interval (30000).
    Setting websocket_ping_timeout=30000
[C 2026-02-05 08:16:42.267 KernelGatewayApp] received signal 15, stopping
Process killed by signal: SIGTERM
.

======================================================================================================== FAILURES =========================================================================================================
________________________________________________________________________________ TestMcpToolExecution.test_timeout_excludes_approval_wait _________________________________________________________________________________

fut = <coroutine object Queue.get at 0x106b38040>, timeout = 0.3980876250025176

    async def wait_for(fut, timeout):
        """Wait for the single Future or coroutine to complete, with timeout.

        Coroutine will be wrapped in Task.

        Returns result of the Future or coroutine.  When a timeout occurs,
        it cancels the task and raises TimeoutError.  To avoid the task
        cancellation, wrap it in shield().

        If the wait is cancelled, the task is also cancelled.

        If the task suppresses the cancellation and returns a value instead,
        that value is returned.

        This function is a coroutine.
        """
        # The special case for timeout <= 0 is for the following case:
        #
        # async def test_waitfor():
        #     func_started = False
        #
        #     async def func():
        #         nonlocal func_started
        #         func_started = True
        #
        #     try:
        #         await asyncio.wait_for(func(), 0)
        #     except asyncio.TimeoutError:
        #         assert not func_started
        #     else:
        #         assert False
        #
        # asyncio.run(test_waitfor())


        if timeout is not None and timeout <= 0:
            fut = ensure_future(fut)

            if fut.done():
                return fut.result()

            await _cancel_and_wait(fut)
            try:
                return fut.result()
            except exceptions.CancelledError as exc:
                raise TimeoutError from exc

        async with timeouts.timeout(timeout):
>           return await fut
                   ^^^^^^^^^

../../../.local/share/uv/python/cpython-3.13.11-macos-aarch64-none/lib/python3.13/asyncio/tasks.py:507:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Queue at 0x106b38590 maxsize=0>

    async def get(self):
        """Remove and return an item from the queue.

        If queue is empty, wait until an item is available.

        Raises QueueShutDown if the queue has been shut down and is empty, or
        if the queue has been shut down immediately.
        """
        while self.empty():
            if self._is_shutdown and self.empty():
                raise QueueShutDown
            getter = self._get_loop().create_future()
            self._getters.append(getter)
            try:
>               await getter
E               asyncio.exceptions.CancelledError

../../../.local/share/uv/python/cpython-3.13.11-macos-aarch64-none/lib/python3.13/asyncio/queues.py:186: CancelledError

The above exception was the direct cause of the following exception:

self = <tests.integration.test_code_exec.TestMcpToolExecution object at 0x105e20f50>, code_executor = <ipybox.code_exec.CodeExecutor object at 0x106b55220>

        @pytest.mark.asyncio
        async def test_timeout_excludes_approval_wait(self, code_executor: CodeExecutor):
            """Test that approval wait time does not consume execution timeout."""
            code = f"""
    from {MCP_SERVER_NAME}.tool_2 import run, Params
    result = run(Params(s="hello"))
    print(result)
    """

            results = []
>           async for item in code_executor.stream(code, timeout=0.4):

tests/integration/test_code_exec.py:133:
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _
ipybox/code_exec.py:327: in stream
    item = await next_item()
           ^^^^^^^^^^^^^^^^^
ipybox/code_exec.py:317: in next_item
    return await asyncio.wait_for(queue.get(), timeout=remaining)
           ^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^^
../../../.local/share/uv/python/cpython-3.13.11-macos-aarch64-none/lib/python3.13/asyncio/tasks.py:506: in wait_for
    async with timeouts.timeout(timeout):
               ^^^^^^^^^^^^^^^^^^^^^^^^^
_ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _ _

self = <Timeout [expired]>, exc_type = <class 'asyncio.exceptions.CancelledError'>, exc_val = CancelledError(), exc_tb = <traceback object at 0x106b5c400>

    async def __aexit__(
        self,
        exc_type: Optional[Type[BaseException]],
        exc_val: Optional[BaseException],
        exc_tb: Optional[TracebackType],
    ) -> Optional[bool]:
        assert self._state in (_State.ENTERED, _State.EXPIRING)

        if self._timeout_handler is not None:
            self._timeout_handler.cancel()
            self._timeout_handler = None

        if self._state is _State.EXPIRING:
            self._state = _State.EXPIRED

            if self._task.uncancel() <= self._cancelling and exc_type is not None:
                # Since there are no new cancel requests, we're
                # handling this.
                if issubclass(exc_type, exceptions.CancelledError):
>                   raise TimeoutError from exc_val
E                   TimeoutError

../../../.local/share/uv/python/cpython-3.13.11-macos-aarch64-none/lib/python3.13/asyncio/timeouts.py:116: TimeoutError
================================================================================================= short test summary info =================================================================================================
FAILED tests/integration/test_code_exec.py::TestMcpToolExecution::test_timeout_excludes_approval_wait - TimeoutError
============================================================================================== 1 failed, 14 passed in 44.11s ==============================================================================================
