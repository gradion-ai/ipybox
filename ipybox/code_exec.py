import asyncio
import time
from contextlib import AsyncExitStack, asynccontextmanager
from dataclasses import dataclass
from pathlib import Path
from typing import AsyncIterator

from ipybox.kernel_mgr.client import ExecutionError, ExecutionResult, KernelClient
from ipybox.kernel_mgr.server import KernelGateway
from ipybox.tool_exec.approval.client import ApprovalClient, ApprovalRequest
from ipybox.tool_exec.client import reset
from ipybox.tool_exec.server import ToolServer
from ipybox.utils import find_free_port


class CodeExecutionError(Exception):
    """Raised when code execution in an IPython kernel fails."""

    pass


@dataclass
class CodeExecutionResult:
    """The result of a successful code execution.

    Attributes:
        text: Output text generated during execution, or `None` if no output.
        images: Paths to images generated during execution.
    """

    text: str | None
    images: list[Path]


@dataclass
class CodeExecutionChunk:
    """A chunk of output text generated during streaming code execution.

    Only yielded by [`CodeExecutor.stream`][ipybox.code_exec.CodeExecutor.stream]
    when `chunks=True`.

    Attributes:
        text: A chunk of output text.
    """

    text: str


class CodeExecutor:
    """Executes Python code in an IPython kernel with programmatic MCP tool call support.

    `CodeExecutor` launches an embedded
    [`KernelGateway`][ipybox.kernel_mgr.server.KernelGateway] for running Python
    code and an embedded [`ToolServer`][ipybox.tool_exec.server.ToolServer] for
    executing MCP tools. Code is executed in an IPython kernel, providing a
    stateful environment where variables and definitions persist across executions.

    MCP tools can be called from executed code using the API generated by
    [`generate_mcp_sources`][ipybox.mcp_apigen.generate_mcp_sources]. When code calls
    an MCP tool, the tool server receives the request and emits an approval request.
    The client must accept or reject the request before the tool executes.

    Example:
        Generate a Python tool API and execute code that uses it:

        ```python
        from pathlib import Path

        from ipybox import ApprovalRequest, CodeExecutionResult, CodeExecutor
        from ipybox import generate_mcp_sources

        # Generate a Python tool API for the fetch MCP server
        server_params = {"command": "uvx", "args": ["mcp-server-fetch"]}
        await generate_mcp_sources("fetch", server_params, Path("mcptools"))

        # Execute code that calls the generated API
        code = \"\"\"
        from mcptools.fetch import fetch

        result = fetch.run(fetch.Params(url="https://example.com"))
        print(result)
        \"\"\"

        async with CodeExecutor() as executor:
            async for item in executor.stream(code):
                match item:
                    case ApprovalRequest():
                        print(f"Tool call: {item}")
                        await item.accept()
                    case CodeExecutionResult():
                        print(item.text)
        ```
    """

    def __init__(
        self,
        tool_server_host: str = "localhost",
        tool_server_port: int | None = None,
        kernel_gateway_host: str = "localhost",
        kernel_gateway_port: int | None = None,
        kernel_env: dict[str, str] | None = None,
        images_dir: Path | None = None,
        approval_timeout: float | None = None,
        connect_timeout: float = 30,
        sandbox: bool = False,
        sandbox_config: Path | None = None,
        log_level: str = "WARNING",
    ):
        """Configure a code executor with optional sandboxing.

        Args:
            tool_server_host: Hostname for the
                [`ToolServer`][ipybox.tool_exec.server.ToolServer].
            tool_server_port: Port for the tool server. If `None`, a free port
                is selected automatically.
            kernel_gateway_host: Hostname for the
                [`KernelGateway`][ipybox.kernel_mgr.server.KernelGateway].
            kernel_gateway_port: Port for the kernel gateway. If `None`, a free
                port is selected automatically.
            kernel_env: Environment variables to set for the IPython kernel.
                Kernels do not inherit environment variables from the parent
                process.
            images_dir: Directory for saving images generated during code
                execution. Defaults to `images` in the current directory.
            approval_timeout: Timeout in seconds for approval requests. If an
                approval request is not accepted or rejected within this time,
                the tool call fails. If `None`, no timeout is applied.
            connect_timeout: Timeout in seconds for starting MCP servers.
            sandbox: Whether to run the kernel gateway inside Anthropic's
                [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime).
                When enabled, IPython kernels run in a secure sandbox with no
                network access except to the local tool server.
            sandbox_config: Path to a JSON file with sandbox configuration.
                See the Configuration section of the
                [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime)
                README for available options.
            log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).
        """
        self.tool_server_host = tool_server_host
        self.tool_server_port = tool_server_port or find_free_port()

        self.kernel_gateway_host = kernel_gateway_host
        self.kernel_gateway_port = kernel_gateway_port or find_free_port()
        self.kernel_env = kernel_env or {}
        self.images_dir = images_dir

        self.approval_timeout = approval_timeout
        self.connect_timeout = connect_timeout

        self.sandbox = sandbox
        self.sandbox_config = sandbox_config
        self.log_level = log_level

        self._exit_stack = AsyncExitStack()
        self._client: KernelClient

    async def __aenter__(self):
        await self.start()
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.stop()

    async def start(self):
        """Start the executor.

        Starts the tool server, kernel gateway, and connects to the IPython kernel.
        """
        self._client = await self._exit_stack.enter_async_context(self._executor())

    async def stop(self):
        """Stop the executor.

        Stops the tool server, kernel gateway, and disconnects from the IPython
        kernel.
        """
        await self._exit_stack.aclose()

    async def reset(self):
        """Reset execution state.

        Restarts the IPython kernel and stops all started MCP servers. Kernel state
        (variables, definitions, imports) is lost. MCP servers are lazily restarted
        on their next tool call.
        """
        await reset(
            host=self.tool_server_host,
            port=self.tool_server_port,
        )
        await self._client.reset()

    async def stream(
        self, code: str, timeout: float | None = None, chunks: bool = False
    ) -> AsyncIterator[ApprovalRequest | CodeExecutionChunk | CodeExecutionResult]:
        """Execute Python code in the IPython kernel with MCP tool call approval.

        Code can call MCP tools using the API generated by
        [`generate_mcp_sources`][ipybox.mcp_apigen.generate_mcp_sources]. Each
        tool call yields an
        [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest].
        If accepted, the tool executes on the
        [`ToolServer`][ipybox.tool_exec.server.ToolServer] and returns the
        result to the kernel. If rejected, the tool call fails with an error.

        Args:
            code: Python code to execute.
            timeout: Maximum time in seconds to wait for execution to complete.
                If `None`, no timeout is applied. Approval wait time is excluded
                from this timeout budget.
            chunks: Whether to yield
                [`CodeExecutionChunk`][ipybox.code_exec.CodeExecutionChunk] objects
                during execution. When `False`, only
                [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest]
                and [`CodeExecutionResult`][ipybox.code_exec.CodeExecutionResult]
                are yielded.

        Yields:
            [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest]:
                When executed code calls an MCP tool. Accept to execute the tool,
                reject to fail the tool call.
            [`CodeExecutionChunk`][ipybox.code_exec.CodeExecutionChunk]: Output text
                chunks generated during execution (emitted only if `chunks=True`).
            [`CodeExecutionResult`][ipybox.code_exec.CodeExecutionResult]: The final
                result when execution completes successfully.

        Raises:
            CodeExecutionError: If code execution raises an error (syntax errors,
                runtime errors, rejected or timed-out approval requests, MCP tool
                errors). The error message contains the stack trace from the kernel.
            asyncio.TimeoutError: If code execution exceeds the timeout (excluding
                approval wait time).
        """
        queue: asyncio.Queue[ApprovalRequest | str | ExecutionResult | Exception] = asyncio.Queue()
        resume_event = asyncio.Event()
        paused = False
        paused_at = 0.0
        resume_at: float | None = None
        deadline = time.monotonic() + timeout if timeout is not None else None
        timed_out = False
        queue_get_task: asyncio.Task | None = None
        task_finalized = False
        timeout_message = (
            f"Code execution exceeded timeout of {timeout:.2f}s (approval wait excluded)."
            if timeout is not None
            else "Code execution exceeded timeout (approval wait excluded)."
        )

        async def stream_execution():
            try:
                async for item in self._client.stream(code, timeout=None):
                    await queue.put(item)
            except Exception as e:
                await queue.put(e)

        def resume_budget(resume_time: float | None = None):
            nonlocal paused, deadline, paused_at, resume_at
            if not paused:
                return
            paused = False
            if deadline is not None:
                effective_resume = resume_time if resume_time is not None else time.monotonic()
                deadline += effective_resume - paused_at
            resume_at = None
            resume_event.clear()

        async def next_item():
            nonlocal queue_get_task
            if timeout is None:
                return await queue.get()

            while True:
                if paused:
                    if resume_event.is_set():
                        resume_budget(resume_at)
                        if queue_get_task is not None:
                            if queue_get_task.done():
                                item = queue_get_task.result()
                                queue_get_task = None
                                return item
                            queue_get_task.cancel()
                            try:
                                await queue_get_task
                            except asyncio.CancelledError:
                                pass
                            queue_get_task = None
                        continue

                    if queue_get_task is None or queue_get_task.done():
                        queue_get_task = asyncio.create_task(queue.get())
                    resume_task = asyncio.create_task(resume_event.wait())
                    done, pending = await asyncio.wait(
                        {queue_get_task, resume_task},
                        return_when=asyncio.FIRST_COMPLETED,
                    )
                    for task in pending:
                        task.cancel()
                        try:
                            await task
                        except asyncio.CancelledError:
                            pass

                    if resume_task in done and resume_event.is_set():
                        resume_budget(resume_at)
                        if queue_get_task is not None:
                            if queue_get_task.done():
                                item = queue_get_task.result()
                                queue_get_task = None
                                return item
                            queue_get_task.cancel()
                            try:
                                await queue_get_task
                            except asyncio.CancelledError:
                                pass
                            queue_get_task = None
                        continue

                    if queue_get_task in done:
                        item = queue_get_task.result()
                        queue_get_task = None
                        resume_budget()
                        return item

                    continue

                assert deadline is not None
                remaining = deadline - time.monotonic()
                if remaining <= 0:
                    raise asyncio.TimeoutError(timeout_message)
                return await asyncio.wait_for(queue.get(), timeout=remaining)

        async with ApprovalClient(
            callback=queue.put,
            host=self.tool_server_host,
            port=self.tool_server_port,
        ):
            task = asyncio.create_task(stream_execution())
            try:
                while True:
                    item = await next_item()
                    match item:
                        case ApprovalRequest():
                            if timeout is not None:
                                paused = True
                                paused_at = time.monotonic()

                                def _resume():
                                    nonlocal resume_at
                                    resume_at = time.monotonic()
                                    resume_event.set()

                                item.set_on_decision(_resume)
                            yield item
                        case str() if chunks:
                            yield CodeExecutionChunk(text=item)
                        case ExecutionError():
                            raise CodeExecutionError(item.args[0])
                        case Exception():
                            raise item
                        case ExecutionResult():
                            yield CodeExecutionResult(text=item.text, images=item.images)
                            break
            except asyncio.TimeoutError as exc:
                timeout_exc = exc if exc.args else asyncio.TimeoutError(timeout_message)
                timed_out = True
                await self._client.interrupt()
                await asyncio.sleep(0.2)

                stream_exc: Exception | None = None
                if not task.done():
                    try:
                        await asyncio.wait_for(task, timeout=2.0)
                    except asyncio.TimeoutError:
                        task.cancel()
                        try:
                            await task
                        except asyncio.CancelledError:
                            pass
                        except Exception as cancel_exc:
                            stream_exc = cancel_exc
                    except Exception as task_exc:
                        stream_exc = task_exc
                else:
                    try:
                        await task
                    except Exception as task_exc:
                        stream_exc = task_exc

                task_finalized = True

                try:
                    await self._client.drain(timeout=1.0)
                except Exception as drain_exc:
                    raise timeout_exc from drain_exc

                if stream_exc is not None:
                    raise timeout_exc from stream_exc

                raise timeout_exc from exc
            finally:
                if queue_get_task is not None and not queue_get_task.done():
                    queue_get_task.cancel()
                    try:
                        await queue_get_task
                    except asyncio.CancelledError:
                        pass
                if not task_finalized:
                    if timed_out:
                        if not task.done():
                            task.cancel()
                            try:
                                await task
                            except asyncio.CancelledError:
                                pass
                    else:
                        await task

    async def execute(self, code: str, timeout: float | None = None) -> CodeExecutionResult:
        """Execute Python code with automatic approval of all MCP tool calls.

        Convenience method that [executes][ipybox.code_exec.CodeExecutor.stream]
        code, auto-approves any MCP tool calls, and returns the final result
        directly.

        Args:
            code: Python code to execute.
            timeout: Maximum time in seconds to wait for execution to complete.
                If `None`, no timeout is applied. Approval wait time is excluded
                from this timeout budget.

        Returns:
            The execution result containing output text and generated images.

        Raises:
            CodeExecutionError: If code execution raises an error.
            asyncio.TimeoutError: If code execution exceeds the timeout (excluding
                approval wait time).
        """
        async for item in self.stream(code, timeout=timeout, chunks=False):
            match item:
                case ApprovalRequest():
                    await item.accept()
                case CodeExecutionResult():
                    return item

        raise RuntimeError("Code execution completed without result")

    @asynccontextmanager
    async def _executor(self) -> AsyncIterator[KernelClient]:
        async with ToolServer(
            host=self.tool_server_host,
            port=self.tool_server_port,
            approval_required=True,
            approval_timeout=self.approval_timeout,
            connect_timeout=self.connect_timeout,
            log_level=self.log_level,
        ):
            async with KernelGateway(
                host=self.kernel_gateway_host,
                port=self.kernel_gateway_port,
                sandbox=self.sandbox,
                sandbox_config=self.sandbox_config,
                log_level=self.log_level,
                env=self.kernel_env
                | {
                    "TOOL_SERVER_HOST": self.tool_server_host,
                    "TOOL_SERVER_PORT": str(self.tool_server_port),
                },
            ):
                async with KernelClient(
                    host=self.kernel_gateway_host,
                    port=self.kernel_gateway_port,
                    images_dir=self.images_dir,
                ) as client:
                    yield client
