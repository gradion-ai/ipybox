import asyncio
import time
from contextlib import AsyncExitStack, asynccontextmanager
from dataclasses import dataclass
from pathlib import Path
from typing import AsyncIterator

from ipybox.kernel_mgr.client import ExecutionError, ExecutionResult, KernelClient
from ipybox.kernel_mgr.server import KernelGateway
from ipybox.tool_exec.approval.client import ApprovalClient, ApprovalRequest
from ipybox.tool_exec.client import reset
from ipybox.tool_exec.server import ToolServer
from ipybox.utils import find_free_port


class CodeExecutionError(Exception):
    """Raised when code execution in an IPython kernel fails."""

    pass


@dataclass
class CodeExecutionResult:
    """The result of a successful code execution.

    Attributes:
        text: Output text generated during execution, or `None` if no output.
        images: Paths to images generated during execution.
    """

    text: str | None
    images: list[Path]


@dataclass
class CodeExecutionChunk:
    """A chunk of output text generated during streaming code execution.

    Only yielded by [`CodeExecutor.stream`][ipybox.code_exec.CodeExecutor.stream]
    when `chunks=True`.

    Attributes:
        text: A chunk of output text.
    """

    text: str


class CodeExecutor:
    """Executes Python code in an IPython kernel with programmatic MCP tool call support.

    `CodeExecutor` launches an embedded
    [`KernelGateway`][ipybox.kernel_mgr.server.KernelGateway] for running Python
    code and an embedded [`ToolServer`][ipybox.tool_exec.server.ToolServer] for
    executing MCP tools. Code is executed in an IPython kernel, providing a
    stateful environment where variables and definitions persist across executions.

    MCP tools can be called from executed code using the API generated by
    [`generate_mcp_sources`][ipybox.mcp_apigen.generate_mcp_sources]. When code calls
    an MCP tool, the tool server receives the request and emits an approval request.
    The client must accept or reject the request before the tool executes.

    Example:
        Generate a Python tool API and execute code that uses it:

        ```python
        from pathlib import Path

        from ipybox import ApprovalRequest, CodeExecutionResult, CodeExecutor
        from ipybox import generate_mcp_sources

        # Generate a Python tool API for the fetch MCP server
        server_params = {"command": "uvx", "args": ["mcp-server-fetch"]}
        await generate_mcp_sources("fetch", server_params, Path("mcptools"))

        # Execute code that calls the generated API
        code = \"\"\"
        from mcptools.fetch import fetch

        result = fetch.run(fetch.Params(url="https://example.com"))
        print(result)
        \"\"\"

        async with CodeExecutor() as executor:
            async for item in executor.stream(code):
                match item:
                    case ApprovalRequest():
                        print(f"Tool call: {item}")
                        await item.accept()
                    case CodeExecutionResult():
                        print(item.text)
        ```
    """

    def __init__(
        self,
        tool_server_host: str = "localhost",
        tool_server_port: int | None = None,
        kernel_gateway_host: str = "localhost",
        kernel_gateway_port: int | None = None,
        kernel_env: dict[str, str] | None = None,
        images_dir: Path | None = None,
        approval_timeout: float | None = None,
        connect_timeout: float = 30,
        sandbox: bool = False,
        sandbox_config: Path | None = None,
        log_level: str = "WARNING",
    ):
        """Configure a code executor with optional sandboxing.

        Args:
            tool_server_host: Hostname for the
                [`ToolServer`][ipybox.tool_exec.server.ToolServer].
            tool_server_port: Port for the tool server. If `None`, a free port
                is selected automatically.
            kernel_gateway_host: Hostname for the
                [`KernelGateway`][ipybox.kernel_mgr.server.KernelGateway].
            kernel_gateway_port: Port for the kernel gateway. If `None`, a free
                port is selected automatically.
            kernel_env: Environment variables to set for the IPython kernel.
                Kernels do not inherit environment variables from the parent
                process.
            images_dir: Directory for saving images generated during code
                execution. Defaults to `images` in the current directory.
            approval_timeout: Timeout in seconds for approval requests. If an
                approval request is not accepted or rejected within this time,
                the tool call fails. If `None`, no timeout is applied.
            connect_timeout: Timeout in seconds for starting MCP servers.
            sandbox: Whether to run the kernel gateway inside Anthropic's
                [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime).
                When enabled, IPython kernels run in a secure sandbox with no
                network access except to the local tool server.
            sandbox_config: Path to a JSON file with sandbox configuration.
                See the Configuration section of the
                [sandbox-runtime](https://github.com/anthropic-experimental/sandbox-runtime)
                README for available options.
            log_level: Logging level (DEBUG, INFO, WARNING, ERROR, CRITICAL).
        """
        self.tool_server_host = tool_server_host
        self.tool_server_port = tool_server_port or find_free_port()

        self.kernel_gateway_host = kernel_gateway_host
        self.kernel_gateway_port = kernel_gateway_port or find_free_port()
        self.kernel_env = kernel_env or {}
        self.images_dir = images_dir

        self.approval_timeout = approval_timeout
        self.connect_timeout = connect_timeout

        self.sandbox = sandbox
        self.sandbox_config = sandbox_config
        self.log_level = log_level

        self._exit_stack = AsyncExitStack()
        self._client: KernelClient

    async def __aenter__(self):
        await self.start()
        return self

    async def __aexit__(self, exc_type, exc_value, traceback):
        await self.stop()

    async def start(self):
        """Start the executor.

        Starts the tool server, kernel gateway, and connects to the IPython kernel.
        """
        self._client = await self._exit_stack.enter_async_context(self._executor())

    async def stop(self):
        """Stop the executor.

        Stops the tool server, kernel gateway, and disconnects from the IPython
        kernel.
        """
        await self._exit_stack.aclose()

    async def reset(self):
        """Reset execution state.

        Restarts the IPython kernel and stops all started MCP servers. Kernel state
        (variables, definitions, imports) is lost. MCP servers are lazily restarted
        on their next tool call.
        """
        await reset(
            host=self.tool_server_host,
            port=self.tool_server_port,
        )
        await self._client.reset()

    async def stream(
        self, code: str, timeout: float | None = None, chunks: bool = False
    ) -> AsyncIterator[ApprovalRequest | CodeExecutionChunk | CodeExecutionResult]:
        """Execute Python code in the IPython kernel with MCP tool call approval.

        Code can call MCP tools using the API generated by
        [`generate_mcp_sources`][ipybox.mcp_apigen.generate_mcp_sources]. Each
        tool call yields an
        [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest].
        If accepted, the tool executes on the
        [`ToolServer`][ipybox.tool_exec.server.ToolServer] and returns the
        result to the kernel. If rejected, the tool call fails with an error.

        Args:
            code: Python code to execute.
            timeout: Maximum time in seconds to wait for execution to complete.
                If `None`, no timeout is applied. Approval wait time is excluded
                from this timeout budget.
            chunks: Whether to yield
                [`CodeExecutionChunk`][ipybox.code_exec.CodeExecutionChunk] objects
                during execution. When `False`, only
                [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest]
                and [`CodeExecutionResult`][ipybox.code_exec.CodeExecutionResult]
                are yielded.

        Yields:
            [`ApprovalRequest`][ipybox.tool_exec.approval.client.ApprovalRequest]:
                When executed code calls an MCP tool. Accept to execute the tool,
                reject to fail the tool call.
            [`CodeExecutionChunk`][ipybox.code_exec.CodeExecutionChunk]: Output text
                chunks generated during execution (emitted only if `chunks=True`).
            [`CodeExecutionResult`][ipybox.code_exec.CodeExecutionResult]: The final
                result when execution completes successfully.

        Raises:
            CodeExecutionError: If code execution raises an error (syntax errors,
                runtime errors, rejected or timed-out approval requests, MCP tool
                errors). The error message contains the stack trace from the kernel.
            asyncio.TimeoutError: If code execution exceeds the timeout (excluding
                approval wait time).
        """
        worker = _StreamWorker(lambda: self._client.stream(code, timeout=None))
        budget = _build_budget(timeout, worker.queue)

        async with ApprovalClient(
            callback=worker.queue.put,
            host=self.tool_server_host,
            port=self.tool_server_port,
        ):
            await worker.start()
            timed_out = False
            caught_exc: Exception | None = None
            try:
                while True:
                    item = await budget.next_item()
                    match item:
                        case ApprovalRequest():
                            budget.pause()
                            item.on_decision(budget.on_decision)
                            yield item
                        case str() if chunks:
                            yield CodeExecutionChunk(text=item)
                        case ExecutionError():
                            raise CodeExecutionError(item.args[0])
                        case Exception():
                            raise item
                        case ExecutionResult():
                            yield CodeExecutionResult(text=item.text, images=item.images)
                            break
            except asyncio.TimeoutError as exc:
                caught_exc = exc
                timed_out = True
                await self._client.interrupt_and_drain()
                stream_exc = await worker.finalize(timeout=2.0)
                if stream_exc is not None:
                    raise exc from stream_exc
                raise
            except Exception as exc:
                caught_exc = exc
                raise
            finally:
                await budget.cancel_pending()
                if not timed_out:
                    stream_exc = await worker.finalize()
                    if stream_exc is not None and caught_exc is None:
                        raise stream_exc

    async def execute(self, code: str, timeout: float | None = None) -> CodeExecutionResult:
        """Execute Python code with automatic approval of all MCP tool calls.

        Convenience method that [executes][ipybox.code_exec.CodeExecutor.stream]
        code, auto-approves any MCP tool calls, and returns the final result
        directly.

        Args:
            code: Python code to execute.
            timeout: Maximum time in seconds to wait for execution to complete.
                If `None`, no timeout is applied. Approval wait time is excluded
                from this timeout budget.

        Returns:
            The execution result containing output text and generated images.

        Raises:
            CodeExecutionError: If code execution raises an error.
            asyncio.TimeoutError: If code execution exceeds the timeout (excluding
                approval wait time).
        """
        async for item in self.stream(code, timeout=timeout, chunks=False):
            match item:
                case ApprovalRequest():
                    await item.accept()
                case CodeExecutionResult():
                    return item

        raise RuntimeError("Code execution completed without result")

    @asynccontextmanager
    async def _executor(self) -> AsyncIterator[KernelClient]:
        async with ToolServer(
            host=self.tool_server_host,
            port=self.tool_server_port,
            approval_required=True,
            approval_timeout=self.approval_timeout,
            connect_timeout=self.connect_timeout,
            log_level=self.log_level,
        ):
            async with KernelGateway(
                host=self.kernel_gateway_host,
                port=self.kernel_gateway_port,
                sandbox=self.sandbox,
                sandbox_config=self.sandbox_config,
                log_level=self.log_level,
                env=self.kernel_env
                | {
                    "TOOL_SERVER_HOST": self.tool_server_host,
                    "TOOL_SERVER_PORT": str(self.tool_server_port),
                },
            ):
                async with KernelClient(
                    host=self.kernel_gateway_host,
                    port=self.kernel_gateway_port,
                    images_dir=self.images_dir,
                ) as client:
                    yield client


class _NoTimeoutBudget:
    """No-timeout variant of the execution budget.

    Acts as a thin passthrough around the queue so CodeExecutor can use a
    uniform interface regardless of whether a timeout is configured.
    """

    def __init__(self, queue: asyncio.Queue[ApprovalRequest | str | ExecutionResult | Exception]):
        self._queue = queue

    def pause(self):
        return

    def on_decision(self, _result: bool | None = None):
        return

    async def next_item(self):
        return await self._queue.get()

    async def cancel_pending(self):
        return


class _TimedBudget:
    """Deadline-based timeout budget with pause/resume support.

    While paused, time does not advance toward the deadline. Resume is triggered
    by approval decisions so only kernel/tool execution time counts.
    """

    def __init__(self, timeout: float, queue: asyncio.Queue[ApprovalRequest | str | ExecutionResult | Exception]):
        self.timeout = timeout
        self._queue = queue
        self._message = f"Code execution exceeded timeout of {timeout:.2f}s (approval wait excluded)."
        self._deadline = time.monotonic() + timeout
        self._paused = False
        self._paused_at = 0.0
        self._resume_at: float | None = None
        self._resume_event = asyncio.Event()
        self._queue_task: asyncio.Task | None = None

    def pause(self):
        if self._paused:
            return
        self._paused = True
        self._paused_at = time.monotonic()

    def signal_resume(self, resume_at: float | None = None):
        self._resume_at = resume_at if resume_at is not None else time.monotonic()
        self._resume_event.set()

    def on_decision(self, _result: bool | None = None):
        self.signal_resume(time.monotonic())

    async def next_item(self):
        while True:
            if self._paused:
                if self._resume_event.is_set():
                    await self._apply_resume()
                    if self._queue_task is not None:
                        if self._queue_task.done():
                            item = await self._pop_queue_task_result()
                            if item is not None:
                                return item
                        await self._cancel_queue_task()
                    continue

                if self._queue_task is None or self._queue_task.done():
                    self._queue_task = asyncio.create_task(self._queue.get())
                resume_task = asyncio.create_task(self._resume_event.wait())
                done, pending = await asyncio.wait(
                    {self._queue_task, resume_task},
                    return_when=asyncio.FIRST_COMPLETED,
                )
                for task in pending:
                    task.cancel()
                    try:
                        await task
                    except asyncio.CancelledError:
                        pass

                if resume_task in done and self._resume_event.is_set():
                    await self._apply_resume()
                    if self._queue_task is not None:
                        if self._queue_task.done():
                            item = await self._pop_queue_task_result()
                            if item is not None:
                                return item
                        await self._cancel_queue_task()
                    continue

                if self._queue_task in done:
                    item = await self._pop_queue_task_result()
                    if item is not None:
                        return item
                    continue

                continue

            remaining = self._deadline - time.monotonic()
            if remaining <= 0:
                raise asyncio.TimeoutError(self._message)
            try:
                return await asyncio.wait_for(self._queue.get(), timeout=remaining)
            except asyncio.TimeoutError as exc:
                raise asyncio.TimeoutError(self._message) from exc

    async def cancel_pending(self):
        if self._queue_task is None or self._queue_task.done():
            return
        await self._cancel_queue_task()

    async def _cancel_queue_task(self):
        if self._queue_task is None:
            return
        self._queue_task.cancel()
        try:
            await self._queue_task
        except asyncio.CancelledError:
            pass
        self._queue_task = None

    async def _pop_queue_task_result(self):
        if self._queue_task is None:
            return None
        try:
            item = self._queue_task.result()
        except asyncio.CancelledError:
            self._queue_task = None
            return None
        self._queue_task = None
        return item

    async def _apply_resume(self):
        if not self._paused:
            self._resume_event.clear()
            self._resume_at = None
            return
        effective_resume = self._resume_at if self._resume_at is not None else time.monotonic()
        self._deadline += effective_resume - self._paused_at
        self._paused = False
        self._resume_at = None
        self._resume_event.clear()


class _StreamWorker:
    """Runs the kernel stream in the background and forwards items to a queue."""

    def __init__(self, stream_factory):
        self._stream_factory = stream_factory
        self.queue: asyncio.Queue[ApprovalRequest | str | ExecutionResult | Exception] = asyncio.Queue()
        self._task: asyncio.Task | None = None
        self._finalized = False

    async def start(self):
        if self._task is not None:
            raise RuntimeError("Stream worker already started")
        self._task = asyncio.create_task(self._run())

    async def finalize(self, timeout: float | None = None) -> Exception | None:
        if self._finalized:
            return None
        self._finalized = True
        if self._task is None:
            return None
        try:
            if timeout is None:
                await self._task
            else:
                await asyncio.wait_for(self._task, timeout=timeout)
        except asyncio.TimeoutError:
            self._task.cancel()
            try:
                await self._task
            except asyncio.CancelledError:
                pass
        except Exception as exc:
            return exc
        return None

    async def _run(self):
        try:
            async for item in self._stream_factory():
                await self.queue.put(item)
        except Exception as exc:
            await self.queue.put(exc)


def _build_budget(timeout: float | None, queue: asyncio.Queue[ApprovalRequest | str | ExecutionResult | Exception]):
    """Create the appropriate budget strategy for the given timeout."""
    if timeout is None:
        return _NoTimeoutBudget(queue)
    return _TimedBudget(timeout, queue)
