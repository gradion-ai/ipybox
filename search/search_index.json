{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Overview","text":"<p><code>ipybox</code> is a lightweight, stateful and secure Python code execution sandbox built with IPython and Docker. Designed for AI agents that interact with their environment through code execution, like <code>freeact</code> agents, it is also well-suited for general-purpose code execution. <code>ipybox</code> is fully open-source and free to use, distributed under the Apache 2.0 license.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Secure Execution: Executes code in Docker container locally or remotely</li> <li>Stateful Execution: Maintains state across code executions using IPython kernels</li> <li>Output Streaming: Provides immediate feedback through direct output streaming</li> <li>Plotting Support: Enables downloading of plots created with visualization libraries</li> <li>MCP Support: Generate Python functions from MCP tools and use them during code execution</li> <li>Dependency Management: Supports package installation during runtime or at build time</li> <li>Resource Management: Context manager based container and IPython kernel lifecycle management</li> <li>Reproducible Environments: Ensures consistent execution environments across different systems</li> </ul>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install ipybox\n</code></pre>"},{"location":"installation/#docker-image","title":"Docker image","text":"<p>Before using <code>ipybox</code>, you need to build a Docker image. This image contains all required dependencies for executing Python code in stateful and isolated sessions.</p>"},{"location":"installation/#default-build","title":"Default build","text":"<p>To build an <code>ipybox</code> Docker image with default settings:</p> <pre><code>python -m ipybox build\n</code></pre> <p>This creates a Docker image tagged as <code>gradion-ai/ipybox</code> containing the base Python dependencies required for the code execution environment.</p> <p>Note</p> <p>By default, containers created from this image will run with the same user and group IDs as the user who built the image, ensuring proper file permissions on mounted host directories. If you use the <code>-r</code> or <code>--root</code> option when building the image, the container will run as root.</p>"},{"location":"installation/#custom-build","title":"Custom build","text":"<p>To create a custom <code>ipybox</code> Docker image with additional dependencies, create a dependencies file (e.g., <code>dependencies.txt</code>). For example:</p> dependencies.txt<pre><code>pandas = \"^2.2\"\nscikit-learn = \"^1.5\"\nmatplotlib = \"^3.9\"\n</code></pre> <p>Then build the image with a custom tag and dependencies:</p> <pre><code>python -m ipybox build -t my-box:v1 -d path/to/dependencies.txt\n</code></pre> <p>The dependencies file should use the Poetry dependency specification format. These packages will be installed alongside the base dependencies required for the execution environment. You can also install additional dependencies at runtime.</p>"},{"location":"usage/","title":"Usage","text":"<p>The two main classes of the <code>ipybox</code> package are <code>ExecutionContainer</code> and <code>ExecutionClient</code>.</p> <p>Note</p> <p>Runnable scripts of the source code on this page are available in the examples directory.</p>"},{"location":"usage/#basic-usage","title":"Basic usage","text":"<p>For executing code in <code>ipybox</code> you first need to create a Docker container from an <code>ipybox</code> Docker image and then an IPython kernel running in that container. This is done with the <code>ExecutionContainer</code> and the <code>ExecutionClient</code> context managers.</p> <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\n\nasync with ExecutionContainer(tag=\"gradion-ai/ipybox\") as container:  # (1)!\n    async with ExecutionClient(port=container.executor_port) as client:  # (2)!\n        result = await client.execute(\"print('Hello, world!')\")  # (3)!\n        print(f\"Output: {result.text}\")  # (4)!\n</code></pre> <ol> <li>Create and start a container for code execution</li> <li>Create and connect to an IPython kernel</li> <li>Execute Python code and await the result</li> <li>Output: <code>Hello, world!</code></li> </ol> <p>The default image used by <code>ExecutionContainer</code> is <code>gradion-ai/ipybox</code>. You can specify a custom image with the <code>tag</code> argument like in <code>ExecutionContainer(tag=\"my-box:v1\")</code>, for example.</p> <p>Note</p> <p>Instead of letting the <code>ExecutionContainer</code> context manager handle the lifecycle of the container, you can also manually manage the container lifecycle.</p>"},{"location":"usage/#state-management","title":"State management","text":"<p>Code execution within the same <code>client</code> context is stateful i.e. you can reference variables from previous executions. Code executions in different client contexts are isolated from each other:</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client_1:  # (1)!\n        result = await client_1.execute(\"x = 1\")  # (2)!\n        assert result.text is None\n        result = await client_1.execute(\"print(x)\")  # (3)!\n        assert result.text == \"1\"\n\n    async with ExecutionClient(port=container.executor_port) as client_2:  # (4)!\n        try:\n            await client_2.execute(\"print(x)\")  # (5)!\n        except ExecutionError as e:\n            assert e.args[0] == \"NameError: name 'x' is not defined\"\n</code></pre> <ol> <li>First client context</li> <li>Execute code that defines variable x</li> <li>Reference variable x defined in previous execution</li> <li>Second client context</li> <li>Variable x is not defined in <code>client_2</code> context</li> </ol>"},{"location":"usage/#output-streaming","title":"Output streaming","text":"<p>The <code>ExecutionClient</code> supports streaming output as it's generated during code execution:</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        code = \"\"\"\n        import time\n        for i in range(5):\n            print(f\"Processing step {i}\")\n            time.sleep(1)\n        \"\"\"  # (1)!\n\n        execution = await client.submit(code)  # (2)!\n        print(\"Streaming output:\")\n        async for chunk in execution.stream():  # (3)!\n            print(f\"Received output: {chunk.strip()}\")  # (4)!\n\n        result = await execution.result()  # (5)!\n        print(\"\\nAggregated output:\")\n        print(result.text)  # (6)!\n</code></pre> <ol> <li>Code that produces gradual output</li> <li>Submit the code for execution</li> <li>Stream the output</li> <li>Prints one line per second:     <pre><code>Received output: Processing step 0\nReceived output: Processing step 1\nReceived output: Processing step 2\nReceived output: Processing step 3\nReceived output: Processing step 4\n</code></pre></li> <li>Get the aggregated output as a single result</li> <li>Prints the aggregated output:     <pre><code>Aggregated output:\nProcessing step 0\nProcessing step 1\nProcessing step 2\nProcessing step 3\nProcessing step 4\n</code></pre></li> </ol> <p>The <code>stream()</code> method accepts an optional <code>timeout</code> argument (defaults to <code>120</code> seconds). In case of timeout, the execution is automatically terminated by interrupting the kernel.</p>"},{"location":"usage/#installing-dependencies-at-runtime","title":"Installing dependencies at runtime","text":"<pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        execution = await client.submit(\"!pip install einops\")  # (1)!\n        async for chunk in execution.stream():  # (2)!\n            print(chunk, end=\"\", flush=True)\n\n        result = await client.execute(\"\"\"\n            import einops\n            print(einops.__version__)\n        \"\"\")  # (3)!\n        print(f\"Output: {result.text}\")  # (4)!\n</code></pre> <ol> <li>Install the <code>einops</code> package using pip</li> <li>Stream the installation progress. Something like     <pre><code>Collecting einops\nDownloading einops-0.8.0-py3-none-any.whl (10.0 kB)\nInstalling collected packages: einops\nSuccessfully installed einops-0.8.0\n</code></pre></li> <li>Import and use the installed package</li> <li>Prints <code>Output: 0.8.0</code></li> </ol> <p>You can also install and use a package within a single execution. There's no need to have two separate executions as done in the example above.</p>"},{"location":"usage/#creating-and-returning-plots","title":"Creating and returning plots","text":"<p>Plots created with <code>matplotlib</code> or other libraries are returned as PIL images. Images are not part of the output stream, but are available as <code>images</code> list in the <code>result</code> object.</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        execution = await client.submit(\"\"\"\n            !pip install matplotlib\n\n            import matplotlib.pyplot as plt\n            import numpy as np\n\n            x = np.linspace(0, 10, 100)\n            plt.figure(figsize=(8, 6))\n            plt.plot(x, np.sin(x))\n            plt.title('Sine Wave')\n            plt.show()\n\n            print(\"Plot generation complete!\")\n            \"\"\")  # (1)!\n\n        async for chunk in execution.stream():  # (2)!\n            print(chunk, end=\"\", flush=True)\n\n        result = await execution.result()\n        result.images[0].save(\"sine.png\")  # (3)!\n</code></pre> <ol> <li>Install <code>matplotlib</code> and generate a plot</li> <li>Stream output text (installation progress and <code>print</code> statement)</li> <li>Get attached image from execution result and save it as sine.png</li> </ol>"},{"location":"usage/#bind-mounts","title":"Bind mounts","text":"<p>Bind mounts allow executed code to read and write files on the host machine.</p> <pre><code>await aiofiles.os.makedirs(\"data\", exist_ok=True)\nawait aiofiles.os.makedirs(\"output\", exist_ok=True)\n\nbinds = {  # (1)!\n    \"./data\": \"data\",  # (2)!\n    \"./output\": \"output\",  # (3)!\n}\n\nasync with aiofiles.open(\"data/input.txt\", \"w\") as f:\n    await f.write(\"hello world\")\n\nasync with ExecutionContainer(binds=binds) as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        await client.execute(\"\"\"\n            with open('data/input.txt') as f:\n                data = f.read()\n\n            processed = data.upper()\n\n            with open('output/result.txt', 'w') as f:\n                f.write(processed)\n        \"\"\")  # (4)!\n\nasync with aiofiles.open(\"output/result.txt\", \"r\") as f:  # (5)!\n    result = await f.read()\n    assert result == \"HELLO WORLD\"\n</code></pre> <ol> <li>Map host paths to container paths.</li> <li>For reading files from host.</li> <li>For writing files to host.</li> <li>Read from mounted <code>data</code> directory, convert to uppercase and write to mounted <code>output</code> directory</li> <li>Verify the results on host</li> </ol>"},{"location":"usage/#environment-variables","title":"Environment variables","text":"<p>Environment variables can be set on the container for passing secrets or configuration data, for example.</p> <pre><code># Define environment variables for the container\nenv = {\"API_KEY\": \"secret-key-123\", \"DEBUG\": \"1\"}  # (1)!\n\nasync with ExecutionContainer(env=env) as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        result = await client.execute(\"\"\"\n            import os\n\n            api_key = os.environ['API_KEY']\n            print(f\"Using API key: {api_key}\")\n\n            debug = bool(int(os.environ.get('DEBUG', '0')))\n            if debug:\n                print(\"Debug mode enabled\")\n        \"\"\")  # (2)!\n        print(result.text)  # (3)!\n</code></pre> <ol> <li>Define environment variables for the container</li> <li>Access environment variables in executed code</li> <li>Prints     <pre><code>Using API key: secret-key-123\nDebug mode enabled\n</code></pre></li> </ol>"},{"location":"usage/#manual-container-lifecycle-management","title":"Manual container lifecycle management","text":"<p>Instead of using <code>ExecutionContainer</code> as a context manager, you can also manually <code>run()</code> and <code>kill()</code> the container. Setting a user-defined port (e.g. <code>7777</code> in the example below) is optional.</p> <p>This is useful for running the container on a separate host listening to a user-defined host port (e.g. <code>7777</code> in the example below).</p> <pre><code>container = ExecutionContainer(executor_port=7777)  # (1)!\nawait container.run()  # (2)!\nassert container.executor_port == 7777\n\n# do some work ...\n\nawait container.kill()  # (3)!\n</code></pre> <ol> <li>Create an <code>ExecutionContainer</code> instance using a fixed port.</li> <li>Run the container (detached).</li> <li>Cleanup.</li> </ol>"},{"location":"usage/#using-a-remote-docker_host","title":"Using a remote <code>DOCKER_HOST</code>","text":"<p>If you want to run the execution container on a remote host but want to manage the container locally, you can set the <code>DOCKER_HOST</code> environment variable to the remote host. The following example assumes that the remote Docker daemon has been configured to accept <code>tcp</code> connections at port <code>2375</code>.</p> <pre><code>HOST = \"192.168.94.50\"  # (1)!\nos.environ[\"DOCKER_HOST\"] = f\"tcp://{HOST}:2375\"  # (2)!\n\nasync with ExecutionContainer(tag=\"ghcr.io/gradion-ai/ipybox:minimal\") as container:  # (3)!\n    async with ExecutionClient(host=HOST, port=container.executor_port) as client:  # (4)!\n        result = await client.execute(\"17 ** 0.13\")\n        print(f\"Output: {result.text}\")\n</code></pre> <ol> <li>Example IP address of the remote Docker host</li> <li>Remote Docker daemon is accessible via <code>tcp</code> at port <code>2375</code></li> <li>Creates a container on the remote host</li> <li>Create an IPython kernel in the remote container</li> </ol>"},{"location":"usage/#using-mcp-servers","title":"Using MCP servers","text":"<p><code>ipybox</code> can generate Python code from MCP server metadata. A Python function is generated per MCP tool with function parameters from the tool's input schema. When calling the function, the corresponding tool is executed on the MCP server.</p> <p>The generated Python code can be retrieved from the server and provided to an LLM for further processing. For example, this is exactly what <code>freeact</code> agents are doing when utilizing and composing MCP tools in code actions.</p> <p><code>ipybox</code> supports both <code>stdio</code> based and <code>sse</code> based MCP servers. A <code>stdio</code> example is shown in the following. For <code>sse</code> based MCP server, provide a server URL as <code>server_params</code> e.g. <code>{\"url\": \"https://&lt;host&gt;:&lt;port&gt;/sse\"}</code></p> <p>Note</p> <p><code>stdio</code> based MCP servers are always executed inside the <code>ipybox</code> Docker container.</p> <pre><code>from ipybox import ExecutionClient, ExecutionContainer, ResourceClient\n\nserver_params = {  # (1)!\n    \"command\": \"uvx\",\n    \"args\": [\"mcp-server-fetch\"],\n}\n\nasync with ExecutionContainer(tag=\"gradion-ai/ipybox\") as container:\n    async with ResourceClient(port=container.resource_port) as client:  # (2)!\n        generate_result = await client.generate_mcp_sources(  # (3)!\n            relpath=\"mcpgen\",\n            server_name=\"fetchurl\",\n            server_params=server_params,\n        )\n        assert generate_result == [\"fetch\"]  # (4)!\n\n        generated_sources = await client.get_mcp_sources(  # (5)!\n            relpath=\"mcpgen\",\n            server_name=\"fetchurl\",\n        )\n        assert \"def fetch(params: Params) -&gt; str:\" in generated_sources[\"fetch\"]\n\n        generated_sources = await client.get_module_sources(  # (6)!\n            module_names=[\"mcpgen.fetchurl.fetch\"],\n        )\n        assert \"def fetch(params: Params) -&gt; str:\" in generated_sources[\"mcpgen.fetchurl.fetch\"]\n\n    async with ExecutionClient(port=container.executor_port) as client:\n        result = await client.execute(\"\"\"\n            from mcpgen.fetchurl.fetch import Params, fetch\n            print(fetch(Params(url=\"https://www.gradion.ai\"))[:375])\n        \"\"\")  # (7)!\n        print(result.text)  # (8)!\n</code></pre> <ol> <li>An MCP server that fetches content from URLs.</li> <li>A <code>ResourceClient</code> is used for generating MCP source code and retrieving it</li> <li>Generate client code (functions, inputs, ...) from MCP server metadata</li> <li>List of tool names provided bythe MCP server</li> <li>Retrieve generated code by reading it from the <code>ipybox</code> container filesystem</li> <li>Retrieve generated code by loading the corresponding Python module</li> <li>Execute code that imports and uses the generated MCP client code.</li> <li>Prints <pre><code>```\n                         ___                    _\n   ____ __________ _____/ (_)___  ____   ____ _(_)\n  / __ `/ ___/ __ `/ __  / / __ \\/ __ \\ / __ `/ /\n / /_/ / /  / /_/ / /_/ / / /_/ / / / // /_/ / /\n \\__, /_/   \\__,_/\\__,_/_/\\____/_/ /_(_)__,_/_/\n/____/\n```\n</code></pre></li> </ol>"},{"location":"api/execution_client/","title":"ExecutionClient","text":""},{"location":"api/execution_client/#ipybox.executor.ExecutionClient","title":"ExecutionClient","text":"<pre><code>ExecutionClient(\n    port: int,\n    host: str = \"localhost\",\n    heartbeat_interval: float = 10,\n)\n</code></pre> <p>A context manager for executing code in an IPython kernel.</p> <p>Parameters:</p> Name Type Description Default <code>host</code> <code>str</code> <p>Hostname where the code execution container is running</p> <code>'localhost'</code> <code>port</code> <code>int</code> <p>Host port for the container's executor port</p> required <code>heartbeat_interval</code> <code>float</code> <p>Interval in seconds between heartbeat pings. Defaults to 10.</p> <code>10</code> Example <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\nbinds = {\"/host/path\": \"example/path\"}\nenv = {\"API_KEY\": \"secret\"}\n\nasync with ExecutionContainer(binds=binds, env=env) as container:\n    async with ExecutionClient(host=\"localhost\", port=container.executor_port) as client:\n        result = await client.execute(\"print('Hello, world!')\")\n        print(result.text)\n</code></pre> <p>Hello, world!</p> Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, port: int, host: str = \"localhost\", heartbeat_interval: float = 10):\n    self.port = port\n    self.host = host\n\n    self._heartbeat_interval = heartbeat_interval\n    self._heartbeat_callback = None\n\n    self._kernel_id = None\n    self._ws: WebSocketClientConnection\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.kernel_id","title":"kernel_id  <code>property</code>","text":"<pre><code>kernel_id\n</code></pre> <p>The ID of the running IPython kernel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If not connected to a kernel</p>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(retries: int = 10, retry_interval: float = 1.0)\n</code></pre> <p>Creates and connects to an IPython kernel.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>Number of connection attempts. Defaults to 10.</p> <code>10</code> <code>retry_interval</code> <code>float</code> <p>Delay between retries in seconds. Defaults to 1.0.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If connection cannot be established after all retries</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def connect(self, retries: int = 10, retry_interval: float = 1.0):\n    \"\"\"Creates and connects to an IPython kernel.\n\n    Args:\n        retries: Number of connection attempts. Defaults to 10.\n        retry_interval: Delay between retries in seconds. Defaults to 1.0.\n\n    Raises:\n        ConnectionError: If connection cannot be established after all retries\n    \"\"\"\n    for _ in range(retries):\n        try:\n            self._kernel_id = await self._create_kernel()\n            break\n        except Exception:\n            await asyncio.sleep(retry_interval)\n    else:\n        raise ConnectionError(\"Failed to create kernel\")\n\n    self._ws = await websocket_connect(HTTPRequest(url=self.kernel_ws_url))\n    logger.info(\"Connected to kernel\")\n\n    self.heartbeat_callback = PeriodicCallback(self._ping_kernel, self._heartbeat_interval * 1000)\n    self.heartbeat_callback.start()\n    logger.info(f\"Started heartbeat (interval = {self._heartbeat_interval}s)\")\n\n    await self._init_kernel()\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect()\n</code></pre> <p>Closes the connection to the kernel and cleans up resources.</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def disconnect(self):\n    \"\"\"Closes the connection to the kernel and cleans up resources.\"\"\"\n    self.heartbeat_callback.stop()\n    self._ws.close()\n    async with aiohttp.ClientSession() as session:\n        async with session.delete(self.kernel_http_url):\n            pass\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(code: str, timeout: float = 120) -&gt; ExecutionResult\n</code></pre> <p>Executes code and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to execute</p> required <code>timeout</code> <code>float</code> <p>Maximum execution time in seconds. Defaults to 120.</p> <code>120</code> <p>Returns:</p> Type Description <code>ExecutionResult</code> <p>ExecutionResult object</p> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If code execution raised an error</p> <code>TimeoutError</code> <p>If execution exceeds timeout duration</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def execute(self, code: str, timeout: float = 120) -&gt; ExecutionResult:\n    \"\"\"Executes code and returns the result.\n\n    Args:\n        code: Code to execute\n        timeout: Maximum execution time in seconds. Defaults to 120.\n\n    Returns:\n        ExecutionResult object\n\n    Raises:\n        ExecutionError: If code execution raised an error\n        asyncio.TimeoutError: If execution exceeds timeout duration\n    \"\"\"\n    execution = await self.submit(code)\n    return await execution.result(timeout=timeout)\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.submit","title":"submit  <code>async</code>","text":"<pre><code>submit(code: str) -&gt; Execution\n</code></pre> <p>Submits code for execution and returns an Execution object to track it.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to execute</p> required <p>Returns:</p> Type Description <code>Execution</code> <p>An Execution object to track the code execution</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def submit(self, code: str) -&gt; Execution:\n    \"\"\"Submits code for execution and returns an Execution object to track it.\n\n    Args:\n        code: Python code to execute\n\n    Returns:\n        An Execution object to track the code execution\n    \"\"\"\n    req_id = uuid4().hex\n    req = {\n        \"header\": {\n            \"username\": \"\",\n            \"version\": \"5.0\",\n            \"session\": \"\",\n            \"msg_id\": req_id,\n            \"msg_type\": \"execute_request\",\n        },\n        \"parent_header\": {},\n        \"channel\": \"shell\",\n        \"content\": {\n            \"code\": code,\n            \"silent\": False,\n            \"store_history\": False,\n            \"user_expressions\": {},\n            \"allow_stdin\": False,\n        },\n        \"metadata\": {},\n        \"buffers\": {},\n    }\n\n    await self._send_request(req)\n    return Execution(client=self, req_id=req_id)\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionResult","title":"ExecutionResult  <code>dataclass</code>","text":"<pre><code>ExecutionResult(text: str | None, images: list[Image])\n</code></pre> <p>The result of a code execution.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Output text generated during execution</p> required <code>images</code> <code>list[Image]</code> <p>List of images generated during execution</p> required"},{"location":"api/execution_client/#ipybox.executor.Execution","title":"Execution","text":"<pre><code>Execution(client: ExecutionClient, req_id: str)\n</code></pre> <p>A code execution in an IPython kernel.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>ExecutionClient</code> <p>The client instance that created this execution</p> required <code>req_id</code> <code>str</code> <p>Unique identifier for the execution request</p> required Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, client: \"ExecutionClient\", req_id: str):\n    self.client = client\n    self.req_id = req_id\n\n    self._chunks: list[str] = []\n    self._images: list[Image.Image] = []\n\n    self._stream_consumed: bool = False\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.Execution.result","title":"result  <code>async</code>","text":"<pre><code>result(timeout: float = 120) -&gt; ExecutionResult\n</code></pre> <p>Waits for execution to complete and returns the final result.</p> <p>If a timeout is reached, the kernel is interrupted.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds. Defaults to 120.</p> <code>120</code> <p>Returns:</p> Type Description <code>ExecutionResult</code> <p>ExecutionResult object</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If execution exceeds timeout duration</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def result(self, timeout: float = 120) -&gt; ExecutionResult:\n    \"\"\"Waits for execution to complete and returns the final result.\n\n    If a timeout is reached, the kernel is interrupted.\n\n    Args:\n        timeout: Maximum time to wait in seconds. Defaults to 120.\n\n    Returns:\n        ExecutionResult object\n\n    Raises:\n        asyncio.TimeoutError: If execution exceeds timeout duration\n    \"\"\"\n    if not self._stream_consumed:\n        async for _ in self.stream(timeout=timeout):\n            pass\n\n    return ExecutionResult(\n        text=\"\".join(self._chunks).strip() if self._chunks else None,\n        images=self._images,\n    )\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.Execution.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(timeout: float = 120) -&gt; AsyncIterator[str]\n</code></pre> <p>Streams the execution output text as it becomes available.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time to wait in seconds. Defaults to 120.</p> <code>120</code> <p>Yields:</p> Type Description <code>AsyncIterator[str]</code> <p>Output text chunks as they arrive</p> <p>Raises:</p> Type Description <code>TimeoutError</code> <p>If execution exceeds timeout duration</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def stream(self, timeout: float = 120) -&gt; AsyncIterator[str]:\n    \"\"\"Streams the execution output text as it becomes available.\n\n    Args:\n        timeout: Maximum time to wait in seconds. Defaults to 120.\n\n    Yields:\n        Output text chunks as they arrive\n\n    Raises:\n        asyncio.TimeoutError: If execution exceeds timeout duration\n    \"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            async for elem in self._stream():\n                match elem:\n                    case str():\n                        self._chunks.append(elem)\n                        yield elem\n                    case Image.Image():\n                        self._images.append(elem)\n    except asyncio.TimeoutError:\n        await self.client._interrupt_kernel()\n        await asyncio.sleep(0.2)  # TODO: make configurable\n        raise\n    finally:\n        self._stream_consumed = True\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionError","title":"ExecutionError","text":"<pre><code>ExecutionError(message: str, trace: str | None = None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Exception raised when code execution in the IPython kernel fails.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <code>trace</code> <code>str | None</code> <p>Stack trace string representation</p> <code>None</code> Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, message: str, trace: str | None = None):\n    super().__init__(message)\n    self.trace = trace\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when connection to an IPython kernel fails.</p>"},{"location":"api/execution_container/","title":"ExecutionContainer","text":"<p>A context manager for managing the lifecycle of a Docker container used for code execution.</p> <p>It handles the creation, port mapping, volume binding, and cleanup of the container.</p> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Tag of the Docker image to use (defaults to gradion-ai/ipybox)</p> <code>DEFAULT_TAG</code> <code>binds</code> <code>dict[str, str] | None</code> <p>Mapping of host paths to container paths for volume mounting. Host paths may be relative or absolute. Container paths must be relative and are created as subdirectories of <code>/app</code> in the container.</p> <code>None</code> <code>env</code> <code>dict[str, str] | None</code> <p>Environment variables to set in the container</p> <code>None</code> <code>executor_port</code> <code>int | None</code> <p>Host port for the container's executor port. If not provided, a random port will be allocated.</p> <code>None</code> <code>resource_port</code> <code>int | None</code> <p>Host port for the container's resource port. If not provided, a random port will be allocated.</p> <code>None</code> <code>port_allocation_timeout</code> <code>float</code> <p>Timeout in seconds waiting for the container's host port to be allocated. This is only relevant on OSX when <code>port=None</code>.</p> <code>10</code> <code>show_pull_progress</code> <code>bool</code> <p>Whether to show progress when pulling the Docker image.</p> <code>True</code> Example <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\nbinds = {\"/host/path\": \"example/path\"}\nenv = {\"API_KEY\": \"secret\"}\n\nasync with ExecutionContainer(binds=binds, env=env) as container:\n    async with ExecutionClient(host=\"localhost\", port=container.executor_port) as client:\n        result = await client.execute(\"print('Hello, world!')\")\n        print(result.text)\n</code></pre> <p>Hello, world!</p> Source code in <code>ipybox/container.py</code> <pre><code>def __init__(\n    self,\n    tag: str = DEFAULT_TAG,\n    binds: dict[str, str] | None = None,\n    env: dict[str, str] | None = None,\n    executor_port: int | None = None,\n    resource_port: int | None = None,\n    port_allocation_timeout: float = 10,\n    show_pull_progress: bool = True,\n):\n    self.tag = tag\n    self.binds = binds or {}\n    self.env = env or {}\n    self.show_pull_progress = show_pull_progress\n\n    self._docker = None\n    self._container = None\n    self._executor_port = executor_port\n    self._resource_port = resource_port\n    self._port_allocation_timeout = port_allocation_timeout\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.executor_port","title":"executor_port  <code>property</code>","text":"<pre><code>executor_port: int\n</code></pre> <p>The host port for the container's executor port.</p> <p>This port is dynamically allocated when the container is started unless explicitly provided.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container is not running</p>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.resource_port","title":"resource_port  <code>property</code>","text":"<pre><code>resource_port: int\n</code></pre> <p>The host port for the container's resource port.</p> <p>This port is dynamically allocated when the container is started unless explicitly provided.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container is not running</p>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.kill","title":"kill  <code>async</code>","text":"<pre><code>kill()\n</code></pre> <p>Kill and remove the Docker container.</p> Source code in <code>ipybox/container.py</code> <pre><code>async def kill(self):\n    \"\"\"\n    Kill and remove the Docker container.\n    \"\"\"\n    if self._container:\n        await self._container.kill()\n\n    if self._docker:\n        await self._docker.close()\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Create and start the Docker container.</p> Source code in <code>ipybox/container.py</code> <pre><code>async def run(self):\n    \"\"\"\n    Create and start the Docker container.\n    \"\"\"\n    self._docker = Docker()\n    await self._run()\n</code></pre>"},{"location":"api/resource_client/","title":"ResourceClient","text":""},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient","title":"ResourceClient","text":"<pre><code>ResourceClient(\n    port: int,\n    host: str = \"localhost\",\n    connect_retries: int = 10,\n    connect_retry_interval: float = 1.0,\n)\n</code></pre> Source code in <code>ipybox/resource/client.py</code> <pre><code>def __init__(\n    self,\n    port: int,\n    host: str = \"localhost\",\n    connect_retries: int = 10,\n    connect_retry_interval: float = 1.0,\n):\n    self.port = port\n    self.host = host\n    self._base_url = f\"http://{self.host}:{self.port}\"\n    self._session: aiohttp.ClientSession = None\n    self._connect_retries = connect_retries\n    self._connect_retry_interval = connect_retry_interval\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.generate_mcp_sources","title":"generate_mcp_sources  <code>async</code>","text":"<pre><code>generate_mcp_sources(\n    relpath: str,\n    server_name: str,\n    server_params: dict[str, Any],\n) -&gt; list[str]\n</code></pre> <p>Generate MCP client code from MCP <code>server_params</code>.</p> <p>The generated code will be stored in <code>/app/{relpath}/{server_name}/{tool_name}.py</code> in the container for each tool provided by the server.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory.</p> required <code>server_name</code> <code>str</code> <p>An application-defined name for the MCP server.</p> required <code>server_params</code> <code>dict[str, Any]</code> <p>MCP server paramaters. A <code>stdio</code> based MCP server requires a <code>command</code> key, an <code>sse</code> based MCP server requires a <code>url</code> key.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of (sanitized) tool names. Tool names are sanitized to ensure they can be used as Python module names.</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def generate_mcp_sources(self, relpath: str, server_name: str, server_params: dict[str, Any]) -&gt; list[str]:\n    \"\"\"Generate MCP client code from MCP `server_params`.\n\n    The generated code will be stored in `/app/{relpath}/{server_name}/{tool_name}.py`\n    in the container for each tool provided by the server.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory.\n        server_name: An application-defined name for the MCP server.\n        server_params: MCP server paramaters. A `stdio` based MCP server requires\n            a `command` key, an `sse` based MCP server requires a `url` key.\n\n    Returns:\n        List of (sanitized) tool names. Tool names are sanitized to\n            ensure they can be used as Python module names.\n    \"\"\"\n    url = f\"{self._base_url}/mcp/{relpath}/{server_name}\"\n    async with self._session.put(url, json=server_params) as response:\n        response.raise_for_status()\n        return await response.json()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.get_mcp_sources","title":"get_mcp_sources  <code>async</code>","text":"<pre><code>get_mcp_sources(\n    relpath: str, server_name: str\n) -&gt; dict[str, str]\n</code></pre> <p>Get generated MCP client code for a given MCP server.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory.</p> required <code>server_name</code> <code>str</code> <p>An application-defined name for the MCP server.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of tool names and their corresponding source code.</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def get_mcp_sources(self, relpath: str, server_name: str) -&gt; dict[str, str]:\n    \"\"\"Get generated MCP client code for a given MCP server.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory.\n        server_name: An application-defined name for the MCP server.\n\n    Returns:\n        Dictionary of tool names and their corresponding source code.\n    \"\"\"\n    url = f\"{self._base_url}/mcp/{relpath}\"\n    async with self._session.get(url, params={\"server_name\": server_name}) as response:\n        response.raise_for_status()\n        return await response.json()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.get_module_sources","title":"get_module_sources  <code>async</code>","text":"<pre><code>get_module_sources(\n    module_names: list[str],\n) -&gt; dict[str, str]\n</code></pre> <p>Get source code for Python modules.</p> <p>Parameters:</p> Name Type Description Default <code>module_names</code> <code>list[str]</code> <p>List of module names to get source code for.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Dictionary of module names and their corresponding source code.</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def get_module_sources(self, module_names: list[str]) -&gt; dict[str, str]:\n    \"\"\"Get source code for Python modules.\n\n    Args:\n        module_names: List of module names to get source code for.\n\n    Returns:\n        Dictionary of module names and their corresponding source code.\n    \"\"\"\n    url = f\"{self._base_url}/modules\"\n    async with self._session.get(url, params={\"q\": module_names}) as response:\n        response.raise_for_status()\n        return await response.json()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>Exception</code></p> <p>Exception raised when connection to the resource server fails.</p>"}]}