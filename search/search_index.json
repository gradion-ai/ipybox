{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Introduction","text":""},{"location":"#overview","title":"Overview","text":"<p><code>ipybox</code> is a lightweight and secure Python code execution sandbox based on IPython and Docker. You can run it locally on your computer or remotely in an environment of your choice - no API key required.</p> <p>While optimized for AI agents that interact with their environment through code execution, such as <code>freeact</code> agents, <code>ipybox</code> also serves as a general-purpose sandbox for secure code execution. It is fully open-source and distributed under the Apache 2.0 license.</p> <p></p>"},{"location":"#features","title":"Features","text":"<ul> <li>Secure code execution inside Docker containers</li> <li>Restrict network access with a configurable firewall</li> <li>Stateful code execution with IPython kernels</li> <li>Stream code execution output as it is generated</li> <li>Install Python packages at build time or runtime</li> <li>Return plots generated with visualization libraries</li> <li>Invocation of MCP servers via generated client code</li> <li>Flexible deployment options, local or remote</li> <li><code>asyncio</code> API for managing the execution environment</li> </ul>"},{"location":"docker/","title":"Docker images","text":"<p>You can either use one of the prebuilt <code>ipybox</code> Docker images provided by <code>freeact</code> or build your own image with default or custom dependencies.</p>"},{"location":"docker/#default-image","title":"Default image","text":"<p>To build a default <code>ipybox</code> Docker image with name <code>gradion-ai/ipybox</code> and minimal dependencies, run:</p> <pre><code>python -m ipybox build\n</code></pre>"},{"location":"docker/#custom-image","title":"Custom image","text":"<p>To build a custom <code>ipybox</code> Docker image with additional Python packages preinstalled, create a <code>dependencies.txt</code> file that follows the PEP 631 dependency specification format. For example:</p> dependencies.txt<pre><code>\"pandas&gt;=2.2,&lt;3\",\n\"scikit-learn&gt;=1.5,&lt;2\",\n\"matplotlib&gt;=3.9,&lt;4\"\n</code></pre> <p>Then build the image by referencing the <code>dependencies.txt</code> file and optionally providing a custom tag:</p> <pre><code>python -m ipybox build -d dependencies.txt -t gradion-ai/ipybox-custom:v1\n</code></pre> <p>Code executed in containers of the custom <code>gradion-ai/ipybox-custom:v1</code> image can now import these packages.</p> <p>Note</p> <p>Containers created from images that have been built without the <code>-r</code> or <code>--root</code> option will run with the same user and group IDs as the user who built the image. With the <code>-r</code> or <code>--root</code> option, containers will run as <code>root</code>.</p> <p>Tip</p> <p>You can also install packages at runtime.</p>"},{"location":"installation/","title":"Installation","text":"<pre><code>pip install ipybox\n</code></pre>"},{"location":"quickstart/","title":"Quickstart","text":"<p>Install <code>ipybox</code> with:</p> <pre><code>pip install ipybox\n</code></pre> <p>Execute Python code in an <code>ipybox</code> container:</p> <pre><code>import asyncio\n\nfrom ipybox import ExecutionClient, ExecutionContainer\n\n\nasync def main():\n    tag = \"ghcr.io/gradion-ai/ipybox:minimal\"  # (1)!\n    async with ExecutionContainer(tag) as container:  # (2)!\n        async with ExecutionClient(port=container.executor_port) as client:  # (3)!\n            result = await client.execute(\"print('Hello, world!')\")  # (4)!\n            print(f\"Output: {result.text}\")  # (5)!\n\n\nif __name__ == \"__main__\":\n    asyncio.run(main())\n</code></pre> <ol> <li>Name and tag of a prebuilt <code>ipybox</code> Docker image.</li> <li>Create and start a code execution container and remove it on context manager exit.</li> <li>Create an IPython kernel in the container and remove it on context manager exit.</li> <li>Execute Python code in the kernel and await the result.</li> <li>Prints: <code>Output: Hello, world!</code></li> </ol>"},{"location":"usage/","title":"Usage","text":"<p>Code examples in the following sections are from the project's examples directory. They use a default <code>gradion-ai/ipybox</code> Docker image that you need to build yourself with</p> <pre><code>python -m ipybox build\n</code></pre> <p>Tip</p> <p>Alternatively, you can also use one of the prebuilt Docker images, as done in quickstart, for example.</p>"},{"location":"usage/#basic-usage","title":"Basic usage","text":"<p>Use the <code>ExecutionContainer</code> context manager to create a container from an <code>ipybox</code> Docker image. The container is created on entering the context manager and removed on exit. Use the <code>ExecutionClient</code> context manager to manage the lifecycle of an IPython kernel within the container. A kernel is created on entering the context manager and removed on exit. Call <code>execute</code> on an <code>ExecutionClient</code> instance to execute code in its kernel.</p> <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\n\nasync with ExecutionContainer(tag=\"gradion-ai/ipybox\") as container:  # (1)!\n    async with ExecutionClient(port=container.executor_port) as client:  # (2)!\n        result = await client.execute(\"print('Hello, world!')\")  # (3)!\n        print(f\"Output: {result.text}\")  # (4)!\n</code></pre> <ol> <li>Create and start a code execution container</li> <li>Create an IPython kernel in the container</li> <li>Execute Python code and await the result</li> <li>Prints: <code>Output: Hello, world!</code></li> </ol> <p>The <code>execute</code> method accepts an optional <code>timeout</code> argument (defaults to <code>120</code> seconds). On timeout, the execution is terminated by interrupting the kernel and a <code>TimeoutError</code> is raised.</p> <p>Info</p> <p>Instead of using the <code>ExecutionContainer</code> context manager for lifecycle management, you can also manually <code>run</code> and <code>kill</code> a container.</p> <pre><code>container = ExecutionContainer()  # (1)!\nawait container.run()  # (2)!\n\n# do some work ...\n\nawait container.kill()  # (3)!\n</code></pre> <ol> <li>Create an <code>ExecutionContainer</code> instance.</li> <li>Run the container (detached).</li> <li>Kill the container.</li> </ol>"},{"location":"usage/#stateful-code-execution","title":"Stateful code execution","text":"<p>Code executions with the same <code>ExecutionClient</code> instance are stateful. Definitions and variables from previous executions can be used in later executions. Code executions with different <code>ExecutionClient</code> instances run in different kernels and do not share in-memory state.</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client_1:  # (1)!\n        result = await client_1.execute(\"x = 1\")  # (2)!\n        assert result.text is None\n        result = await client_1.execute(\"print(x)\")  # (3)!\n        assert result.text == \"1\"\n\n    async with ExecutionClient(port=container.executor_port) as client_2:  # (4)!\n        try:\n            await client_2.execute(\"print(x)\")  # (5)!\n        except ExecutionError as e:\n            assert e.args[0] == \"NameError: name 'x' is not defined\"\n</code></pre> <ol> <li>First client instance</li> <li>Execute code that defines variable <code>x</code></li> <li>Use variable <code>x</code> defined in previous execution</li> <li>Second client instance</li> <li>Variable <code>x</code> is not defined in <code>client_2</code>'s kernel</li> </ol> <p>Note</p> <p>While kernels in the same container don't share in-memory state, they can still exchange data by reading and writing files to the shared container filesystem. For full isolation of code executions, you need to run them in different containers.</p>"},{"location":"usage/#execution-output-streaming","title":"Execution output streaming","text":"<p>Instead of waiting for code execution to complete, output can also be streamed as it is generated:</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        code = \"\"\"\n        import time\n        for i in range(5):\n            print(f\"Processing step {i}\")\n            time.sleep(1)\n        \"\"\"  # (1)!\n\n        execution = await client.submit(code)  # (2)!\n        print(\"Streaming output:\")\n        async for chunk in execution.stream():  # (3)!\n            print(f\"Received output: {chunk.strip()}\")  # (4)!\n\n        result = await execution.result()  # (5)!\n        print(\"\\nAggregated output:\")\n        print(result.text)  # (6)!\n</code></pre> <ol> <li>Code that produces gradual output every second</li> <li>Submit the code for execution</li> <li>Stream the output</li> <li>Prints one line per second:     <pre><code>Received output: Processing step 0\nReceived output: Processing step 1\nReceived output: Processing step 2\nReceived output: Processing step 3\nReceived output: Processing step 4\n</code></pre></li> <li>Get the aggregated output (returns immediately)</li> <li>Prints the aggregated output:     <pre><code>Aggregated output:\nProcessing step 0\nProcessing step 1\nProcessing step 2\nProcessing step 3\nProcessing step 4\n</code></pre></li> </ol>"},{"location":"usage/#restrict-network-access","title":"Restrict network access","text":"<p>A container allows all outbound internet traffic by default. This can be restricted with the <code>init_firewall</code> method to a list of domain names, IP addresses, or CIDR ranges.</p> <pre><code>from ipybox import ExecutionClient, ExecutionContainer\n\n\nCODE = \"\"\"\nimport socket\n\ntry:\n    with socket.create_connection((\"{host}\", 80), timeout=1) as s:\n        print(\"connected\")\nexcept Exception:\n    print(\"timeout\")\n\"\"\"\n\nasync with ExecutionContainer(tag=\"gradion-ai/ipybox\") as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        result = await client.execute(CODE.format(host=\"example.com\"))  # (1)!\n        assert result.text == \"connected\"\n\n        await container.init_firewall([\"gradion.ai\"])  # (2)!\n\n        result = await client.execute(CODE.format(host=\"gradion.ai\"))  # (3)!\n        assert result.text == \"connected\"\n\n        result = await client.execute(CODE.format(host=\"example.com\"))  # (4)!\n        assert result.text == \"timeout\"\n</code></pre> <ol> <li>Internet access is not restricted before firewall initialization</li> <li>Restrict internet access to domain <code>gradion.ai</code></li> <li>Allowed by firewall</li> <li>Blocked by firewall. May take longer than the configured 1 second timeout because <code>example.com</code> resolves to multiple IP addresses and all are tried before failing.</li> </ol> <p>Note</p> <p>The firewall can only be initialized on containers running as a non-root user i.e. containers of <code>ipybox</code> images that were built without the <code>-r</code> or <code>-root</code> flag. An attempt to initialize the firewall on a container running as root will raise an error.</p>"},{"location":"usage/#install-packages-at-runtime","title":"Install packages at runtime","text":"<p>Python packages can be installed at runtime by executing <code>!pip install &lt;package&gt;</code>:</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        execution = await client.submit(\"!pip install einops\")  # (1)!\n        async for chunk in execution.stream():  # (2)!\n            print(chunk, end=\"\", flush=True)\n\n        result = await client.execute(\"\"\"\n            import einops\n            print(einops.__version__)\n        \"\"\")  # (3)!\n        print(f\"Output: {result.text}\")  # (4)!\n</code></pre> <ol> <li>Install the <code>einops</code> package using pip</li> <li>Stream the installation progress. Something like     <pre><code>Collecting einops\nDownloading einops-0.8.0-py3-none-any.whl (10.0 kB)\nInstalling collected packages: einops\nSuccessfully installed einops-0.8.0\n</code></pre></li> <li>Import and use the installed package</li> <li>Prints <code>Output: 0.8.0</code></li> </ol> <p>You can also install and use a package in a single execution step, as shown in the next section, for example.</p>"},{"location":"usage/#generate-plots","title":"Generate plots","text":"<p>Plots generated with <code>matplotlib</code> and other visualization libraries are returned as PIL images. Images are not part of the output stream; they can be obtained from the <code>result</code> object as <code>images</code> list.</p> <pre><code>async with ExecutionContainer() as container:\n    async with ExecutionClient(port=container.executor_port) as client:\n        execution = await client.submit(\"\"\"\n            !pip install matplotlib\n\n            import matplotlib.pyplot as plt\n            import numpy as np\n\n            x = np.linspace(0, 10, 100)\n            plt.figure(figsize=(8, 6))\n            plt.plot(x, np.sin(x))\n            plt.title('Sine Wave')\n            plt.show()\n\n            print(\"Plot generation complete!\")\n            \"\"\")  # (1)!\n\n        async for chunk in execution.stream():  # (2)!\n            print(chunk, end=\"\", flush=True)\n\n        result = await execution.result()\n        result.images[0].save(\"sine.png\")  # (3)!\n</code></pre> <ol> <li>Install <code>matplotlib</code> and generate a plot</li> <li>Stream output text (installation progress and <code>print</code> statement)</li> <li>Get attached image from execution result and save it as sine.png</li> </ol>"},{"location":"usage/#file-operations","title":"File operations","text":"<p>Files and directories can be transferred between the host and container using the <code>ResourceClient</code>.</p> <pre><code>input_dir = Path(\"examples\", \"data\")\n\nasync with ExecutionContainer() as container:\n    async with ResourceClient(port=container.resource_port) as res_client:\n        async with ExecutionClient(port=container.executor_port) as exec_client:\n            await res_client.upload_file(\"data/example.txt\", input_dir / \"example.txt\")  # (1)!\n            await res_client.upload_directory(\"data/subdir\", input_dir / \"subdir\")  # (2)!\n\n            await exec_client.execute(\"\"\"\n                import os\n                import shutil\n                os.makedirs('output', exist_ok=True)\n                shutil.copy('data/example.txt', 'output/example.txt')\n                shutil.copytree('data/subdir', 'output/subdir')\n            \"\"\")  # (3)!\n\n            output_dir = Path(\"examples\", \"output\")\n            output_dir.mkdir(exist_ok=True, parents=True)\n            await res_client.download_file(\"output/example.txt\", output_dir / \"example.txt\")  # (4)!\n            await res_client.download_directory(\"output/subdir\", output_dir / \"subdir\")  # (5)!\n            await res_client.delete_file(\"data/example.txt\")  # (6)!\n</code></pre> <ol> <li>Upload a single file to the container</li> <li>Upload an entire directory to the container</li> <li>Copy files within the container</li> <li>Download a file from the container</li> <li>Download a directory from the container</li> <li>Delete a file in the container</li> </ol>"},{"location":"usage/#environment-variables","title":"Environment variables","text":"<p>Environment variables for the container can be passed to the <code>ExecutionContainer</code> constructor.</p> <pre><code>env = {\"API_KEY\": \"secret-key-123\", \"DEBUG\": \"1\"}\n\nasync with ExecutionContainer(env=env) as container:  # (1)!\n    async with ExecutionClient(port=container.executor_port) as client:\n        result = await client.execute(\"\"\"\n            import os\n\n            api_key = os.environ['API_KEY']\n            print(f\"Using API key: {api_key}\")\n\n            debug = bool(int(os.environ.get('DEBUG', '0')))\n            if debug:\n                print(\"Debug mode enabled\")\n        \"\"\")  # (2)!\n        print(result.text)  # (3)!\n</code></pre> <ol> <li>Set environment variables for the container</li> <li>Access environment variables in executed code</li> <li>Prints     <pre><code>Using API key: secret-key-123\nDebug mode enabled\n</code></pre></li> </ol>"},{"location":"usage/#remote-docker_host","title":"Remote <code>DOCKER_HOST</code>","text":"<p>If you want to run a code execution container on a remote host but manage the container with <code>ExecutionContainer</code> locally, set the <code>DOCKER_HOST</code> environment variable to that host. The following example assumes that the remote Docker daemon has been configured to accept <code>tcp</code> connections at port <code>2375</code>.</p> <pre><code>HOST = \"192.168.94.50\"  # (1)!\nos.environ[\"DOCKER_HOST\"] = f\"tcp://{HOST}:2375\"  # (2)!\n\nasync with ExecutionContainer(tag=\"ghcr.io/gradion-ai/ipybox:minimal\") as container:  # (3)!\n    async with ExecutionClient(host=HOST, port=container.executor_port) as client:  # (4)!\n        result = await client.execute(\"17 ** 0.13\")\n        print(f\"Output: {result.text}\")\n</code></pre> <ol> <li>Example IP address of the remote Docker host</li> <li>Remote Docker daemon is accessible via <code>tcp</code> at port <code>2375</code></li> <li>Creates a container on the remote host</li> <li>Create an IPython kernel in the remote container</li> </ol>"},{"location":"usage/#mcp-integration","title":"MCP integration","text":"<p><code>ipybox</code> supports the invocation of MCP servers in containers via generated MCP client code. An application first calls <code>generate_mcp_sources</code> to generate a Python function for each tool provided by an MCP server, using the tool's input schema. This needs to be done only once per MCP server. Generated functions are then available on the container's Python path.</p> <p>Generated function</p> <p>The example below generates a <code>fetch</code> function from the input schema of the <code>fetch</code> tool provided by the Fetch MCP server.</p> <pre><code>from ipybox import ExecutionClient, ExecutionContainer, ResourceClient\n\nserver_params = {  # (1)!\n    \"command\": \"uvx\",\n    \"args\": [\"mcp-server-fetch\"],\n}\n\nasync with ExecutionContainer(tag=\"gradion-ai/ipybox\") as container:\n    async with ResourceClient(port=container.resource_port) as client:\n        tool_names = await client.generate_mcp_sources(  # (2)!\n            relpath=\"mcpgen\",\n            server_name=\"fetchurl\",\n            server_params=server_params,\n        )\n        assert tool_names == [\"fetch\"]  # (3)!\n\n    async with ExecutionClient(port=container.executor_port) as client:\n        result = await client.execute(\"\"\"\n            from mcpgen.fetchurl.fetch import Params, fetch\n            print(fetch(Params(url=\"https://www.gradion.ai\"))[:375])\n        \"\"\")  # (4)!\n        print(result.text)  # (5)!\n</code></pre> <ol> <li>Configuration of the Fetch MCP server.</li> <li>Generate MCP client code from an MCP server config. One MCP client function is generated per MCP tool.</li> <li>List of tool names provided by the MCP server. A single <code>fetch</code> tool in this example.</li> <li>Execute code that imports and calls the generated MCP client function.</li> <li>Prints <pre><code>```\n                         ___                    _\n   ____ __________ _____/ (_)___  ____   ____ _(_)\n  / __ `/ ___/ __ `/ __  / / __ \\/ __ \\ / __ `/ /\n / /_/ / /  / /_/ / /_/ / / /_/ / / / // /_/ / /\n \\__, /_/   \\__,_/\\__,_/_/\\____/_/ /_(_)__,_/_/\n/____/\n```\n</code></pre></li> </ol> <p>Calling a generated MCP client function, executes the corresponding MCP tool. Tools of <code>stdio</code> based MCP servers are always executed inside the container, while <code>streamable-http</code> or legacy <code>sse</code> based MCP servers are expected to run elsewhere. Generated MCP client code can be downloaded from the container with <code>get_mcp_sources</code> (not shown).</p> <p>Application example</p> <p><code>freeact</code> agents use the <code>ipybox</code> MCP integration for calling MCP tools in their code actions.</p>"},{"location":"usage/#remote-mcp-servers","title":"Remote MCP servers","text":"<p>In addition to <code>stdio</code> based MCP servers that run inside the container, <code>ipybox</code> also supports connecting to remote MCP servers running with <code>streamable-http</code> or legacy <code>sse</code> transports. This is demonstrated below with an example MCP server that is part of the project. Start the server in a separate terminal on the host machine:</p> <pre><code>python tests/mcp_server.py --transport streamable-http --port 8000\n</code></pre> <p>Then connect to it from your Python script:</p> <pre><code>from ipybox import ExecutionClient, ExecutionContainer, ResourceClient\n\n\nserver_params = {  # (1)!\n    \"type\": \"streamable_http\",\n    \"url\": \"http://[YOUR-HOST-IP-ADDRESS]:8000/mcp\",\n}\n\nasync with ExecutionContainer(tag=\"gradion-ai/ipybox\") as container:\n    async with ResourceClient(port=container.resource_port) as client:\n        tool_names = await client.generate_mcp_sources(  # (2)!\n            relpath=\"mcpgen\",\n            server_name=\"test_server\",\n            server_params=server_params,\n        )\n        assert tool_names == [\"tool_1\", \"tool_2\"]  # (3)!\n\n    async with ExecutionClient(port=container.executor_port) as client:\n        result = await client.execute(\"\"\"\n            from mcpgen.test_server.tool_1 import Params, tool_1\n            response = tool_1(Params(s=\"Hello from ipybox!\"))\n            print(response)\n        \"\"\")  # (4)!\n        print(result.text)  # (5)!\n</code></pre> <ol> <li>Configuration of the test MCP server running on the host machine. Replace <code>[YOUR-HOST-IP-ADDRESS]</code> with your host machine's IP address.</li> <li>Generate MCP client code from an MCP server config. One MCP client function is generated per MCP tool.</li> <li>List of tool names provided by the test server: <code>tool_1</code> and <code>tool_2</code></li> <li>Execute code that imports and calls the generated <code>tool_1</code> function</li> <li>Prints: <code>You passed to tool 1: Hello from ipybox!</code></li> </ol>"},{"location":"api/execution_client/","title":"ExecutionClient","text":""},{"location":"api/execution_client/#ipybox.executor.ExecutionClient","title":"ExecutionClient","text":"<pre><code>ExecutionClient(\n    port: int,\n    host: str = \"localhost\",\n    heartbeat_interval: float = 10,\n)\n</code></pre> <p>Context manager for executing code in an IPython kernel running in an <code>ExecutionContainer</code>. The kernel is created on entering the context and destroyed on exit. The container's <code>/app</code> directory is added to the kernel's Python path.</p> <p>Code execution is stateful for a given <code>ExecutionClient</code> instance. Definitions and variables of previous executions are available to subsequent executions.</p> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Host port for the container's executor port</p> required <code>host</code> <code>str</code> <p>Hostname or IP address of the container's host</p> <code>'localhost'</code> <code>heartbeat_interval</code> <code>float</code> <p>Ping interval for keeping the websocket connection to the IPython kernel alive.</p> <code>10</code> Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, port: int, host: str = \"localhost\", heartbeat_interval: float = 10):\n    self.port = port\n    self.host = host\n\n    self._heartbeat_interval = heartbeat_interval\n    self._heartbeat_callback = None\n\n    self._kernel_id = None\n    self._ws: WebSocketClientConnection\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.kernel_id","title":"kernel_id  <code>property</code>","text":"<pre><code>kernel_id\n</code></pre> <p>The ID of the running IPython kernel.</p> <p>Raises:</p> Type Description <code>ValueError</code> <p>If not connected to a kernel</p>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.connect","title":"connect  <code>async</code>","text":"<pre><code>connect(retries: int = 10, retry_interval: float = 1.0)\n</code></pre> <p>Creates an IPython kernel and connects to it.</p> <p>Parameters:</p> Name Type Description Default <code>retries</code> <code>int</code> <p>Number of connection retries.</p> <code>10</code> <code>retry_interval</code> <code>float</code> <p>Delay between connection retries in seconds.</p> <code>1.0</code> <p>Raises:</p> Type Description <code>ConnectionError</code> <p>If connection cannot be established after all retries</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def connect(self, retries: int = 10, retry_interval: float = 1.0):\n    \"\"\"Creates an IPython kernel and connects to it.\n\n    Args:\n        retries: Number of connection retries.\n        retry_interval: Delay between connection retries in seconds.\n\n    Raises:\n        ConnectionError: If connection cannot be established after all retries\n    \"\"\"\n    for _ in range(retries):\n        try:\n            self._kernel_id = await self._create_kernel()\n            break\n        except Exception:\n            await asyncio.sleep(retry_interval)\n    else:\n        raise ConnectionError(\"Failed to create kernel\")\n\n    self._ws = await websocket_connect(HTTPRequest(url=self.kernel_ws_url))\n    logger.info(\"Connected to kernel\")\n\n    self.heartbeat_callback = PeriodicCallback(self._ping_kernel, self._heartbeat_interval * 1000)\n    self.heartbeat_callback.start()\n    logger.info(f\"Started heartbeat (interval = {self._heartbeat_interval}s)\")\n\n    await self._init_kernel()\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.disconnect","title":"disconnect  <code>async</code>","text":"<pre><code>disconnect()\n</code></pre> <p>Disconnects from and deletes the running IPython kernel.</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def disconnect(self):\n    \"\"\"Disconnects from and deletes the running IPython kernel.\"\"\"\n    self.heartbeat_callback.stop()\n    self._ws.close()\n    async with aiohttp.ClientSession() as session:\n        async with session.delete(self.kernel_http_url):\n            pass\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.execute","title":"execute  <code>async</code>","text":"<pre><code>execute(code: str, timeout: float = 120) -&gt; ExecutionResult\n</code></pre> <p>Executes code in this client's IPython kernel and returns the result.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Code to execute</p> required <code>timeout</code> <code>float</code> <p>Maximum time in seconds to wait for the execution result</p> <code>120</code> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If code execution raises an error</p> <code>TimeoutError</code> <p>If code execution duration exceeds the specified timeout</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def execute(self, code: str, timeout: float = 120) -&gt; ExecutionResult:\n    \"\"\"Executes code in this client's IPython kernel and returns the result.\n\n    Args:\n        code: Code to execute\n        timeout: Maximum time in seconds to wait for the execution result\n\n    Raises:\n        ExecutionError: If code execution raises an error\n        asyncio.TimeoutError: If code execution duration exceeds the specified timeout\n    \"\"\"\n    execution = await self.submit(code)\n    return await execution.result(timeout=timeout)\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionClient.submit","title":"submit  <code>async</code>","text":"<pre><code>submit(code: str) -&gt; Execution\n</code></pre> <p>Submits code for execution in this client's IPython kernel and returns an <code>Execution</code> object for consuming the execution result.</p> <p>Parameters:</p> Name Type Description Default <code>code</code> <code>str</code> <p>Python code to execute</p> required <p>Returns:</p> Type Description <code>Execution</code> <p>A <code>Execution</code> object to track the code execution.</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def submit(self, code: str) -&gt; Execution:\n    \"\"\"Submits code for execution in this client's IPython kernel and returns an\n    [`Execution`][ipybox.executor.Execution] object for consuming the execution result.\n\n    Args:\n        code: Python code to execute\n\n    Returns:\n        A [`Execution`][ipybox.executor.Execution] object to track the code execution.\n    \"\"\"\n    req_id = uuid4().hex\n    req = {\n        \"header\": {\n            \"username\": \"\",\n            \"version\": \"5.0\",\n            \"session\": \"\",\n            \"msg_id\": req_id,\n            \"msg_type\": \"execute_request\",\n        },\n        \"parent_header\": {},\n        \"channel\": \"shell\",\n        \"content\": {\n            \"code\": code,\n            \"silent\": False,\n            \"store_history\": False,\n            \"user_expressions\": {},\n            \"allow_stdin\": False,\n        },\n        \"metadata\": {},\n        \"buffers\": {},\n    }\n\n    await self._send_request(req)\n    return Execution(client=self, req_id=req_id)\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionResult","title":"ExecutionResult  <code>dataclass</code>","text":"<pre><code>ExecutionResult(text: str | None, images: list[Image])\n</code></pre> <p>The result of a successful code execution.</p> <p>Parameters:</p> Name Type Description Default <code>text</code> <code>str | None</code> <p>Output text generated during execution</p> required <code>images</code> <code>list[Image]</code> <p>List of images generated during execution</p> required"},{"location":"api/execution_client/#ipybox.executor.Execution","title":"Execution","text":"<pre><code>Execution(client: ExecutionClient, req_id: str)\n</code></pre> <p>A code execution in an IPython kernel.</p> <p>Parameters:</p> Name Type Description Default <code>client</code> <code>ExecutionClient</code> <p>The client that initiated this code execution</p> required <code>req_id</code> <code>str</code> <p>Unique identifier of the code execution request</p> required Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, client: \"ExecutionClient\", req_id: str):\n    self.client = client\n    self.req_id = req_id\n\n    self._chunks: list[str] = []\n    self._images: list[Image.Image] = []\n\n    self._stream_consumed: bool = False\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.Execution.result","title":"result  <code>async</code>","text":"<pre><code>result(timeout: float = 120) -&gt; ExecutionResult\n</code></pre> <p>Retrieves the complete result of this code execution. Waits until the result is available.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time in seconds to wait for the execution result</p> <code>120</code> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If code execution raises an error</p> <code>TimeoutError</code> <p>If code execution duration exceeds the specified timeout</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def result(self, timeout: float = 120) -&gt; ExecutionResult:\n    \"\"\"Retrieves the complete result of this code execution. Waits until the\n    result is available.\n\n    Args:\n        timeout: Maximum time in seconds to wait for the execution result\n\n    Raises:\n        ExecutionError: If code execution raises an error\n        asyncio.TimeoutError: If code execution duration exceeds the specified timeout\n    \"\"\"\n    if not self._stream_consumed:\n        async for _ in self.stream(timeout=timeout):\n            pass\n\n    return ExecutionResult(\n        text=\"\".join(self._chunks).strip() if self._chunks else None,\n        images=self._images,\n    )\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.Execution.stream","title":"stream  <code>async</code>","text":"<pre><code>stream(timeout: float = 120) -&gt; AsyncIterator[str]\n</code></pre> <p>Streams the code execution result as it is generated. Once the stream is consumed, a <code>result</code> is immediately available without waiting.</p> <p>Generated images are not streamed. They can be obtained from the return value of <code>result</code>.</p> <p>Parameters:</p> Name Type Description Default <code>timeout</code> <code>float</code> <p>Maximum time in seconds to wait for the complete execution result</p> <code>120</code> <p>Raises:</p> Type Description <code>ExecutionError</code> <p>If code execution raises an error</p> <code>TimeoutError</code> <p>If code execution duration exceeds the specified timeout</p> Source code in <code>ipybox/executor.py</code> <pre><code>async def stream(self, timeout: float = 120) -&gt; AsyncIterator[str]:\n    \"\"\"Streams the code execution result as it is generated. Once the stream\n    is consumed, a [`result`][ipybox.executor.Execution.result] is immediately\n    available without waiting.\n\n    Generated images are not streamed. They can be obtained from the\n    return value of [`result`][ipybox.executor.Execution.result].\n\n    Args:\n        timeout: Maximum time in seconds to wait for the complete execution result\n\n    Raises:\n        ExecutionError: If code execution raises an error\n        asyncio.TimeoutError: If code execution duration exceeds the specified timeout\n    \"\"\"\n    try:\n        async with asyncio.timeout(timeout):\n            async for elem in self._stream():\n                match elem:\n                    case str():\n                        self._chunks.append(elem)\n                        yield elem\n                    case Image.Image():\n                        self._images.append(elem)\n    except asyncio.TimeoutError:\n        await self.client._interrupt_kernel()\n        await asyncio.sleep(0.2)  # TODO: make configurable\n        raise\n    finally:\n        self._stream_consumed = True\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ExecutionError","title":"ExecutionError","text":"<pre><code>ExecutionError(message: str, trace: str | None = None)\n</code></pre> <p>               Bases: <code>Exception</code></p> <p>Raised when code execution in an IPython kernel raises an error.</p> <p>Parameters:</p> Name Type Description Default <code>message</code> <code>str</code> <p>Error message</p> required <code>trace</code> <code>str | None</code> <p>String representation of the stack trace.</p> <code>None</code> Source code in <code>ipybox/executor.py</code> <pre><code>def __init__(self, message: str, trace: str | None = None):\n    super().__init__(message)\n    self.trace = trace\n</code></pre>"},{"location":"api/execution_client/#ipybox.executor.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a connection to an IPython kernel cannot be established.</p>"},{"location":"api/execution_container/","title":"ExecutionContainer","text":""},{"location":"api/execution_container/#ipybox.container.DEFAULT_TAG","title":"DEFAULT_TAG  <code>module-attribute</code>","text":"<pre><code>DEFAULT_TAG = 'gradion-ai/ipybox'\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer","title":"ExecutionContainer","text":"<pre><code>ExecutionContainer(\n    tag: str = DEFAULT_TAG,\n    binds: dict[str, str] | None = None,\n    env: dict[str, str] | None = None,\n    executor_port: int | None = None,\n    resource_port: int | None = None,\n    port_allocation_timeout: float = 10,\n    show_pull_progress: bool = True,\n)\n</code></pre> <p>Context manager for the lifecycle of a code execution Docker container. A code execution container provides:</p> <ul> <li>a Jupyter Kernel Gateway for stateful code execution   in IPython kernels. Clients connect to it via   <code>ExecutionClient</code> on the container's   executor host port.</li> <li>a resource server for downloading Python module sources and registering MCP servers.   Clients connect to it via <code>ResourceClient</code> on   the container's resource host port.</li> <li>a firewall that can be enabled with init_firewall   to restrict network access to allowed domains, IPv4 addresses, or CIDR ranges.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>tag</code> <code>str</code> <p>Name and optionally tag of the <code>ipybox</code> Docker image to use (format: <code>name:tag</code>)</p> <code>DEFAULT_TAG</code> <code>binds</code> <code>dict[str, str] | None</code> <p>A dictionary mapping host paths to container paths for bind mounts. Host paths may be relative or absolute. Container paths must be relative and are created as subdirectories of <code>/app</code> in the container.</p> <code>None</code> <code>env</code> <code>dict[str, str] | None</code> <p>Environment variables to set in the container</p> <code>None</code> <code>executor_port</code> <code>int | None</code> <p>Host port for the container's executor port. A random port is allocated if not specified.</p> <code>None</code> <code>resource_port</code> <code>int | None</code> <p>Host port for the container's resource port. A random port is allocated if not specified.</p> <code>None</code> <code>port_allocation_timeout</code> <code>float</code> <p>Maximum time in seconds to wait for port random allocation.</p> <code>10</code> <code>show_pull_progress</code> <code>bool</code> <p>Whether to show progress when pulling the Docker image.</p> <code>True</code> Source code in <code>ipybox/container.py</code> <pre><code>def __init__(\n    self,\n    tag: str = DEFAULT_TAG,\n    binds: dict[str, str] | None = None,\n    env: dict[str, str] | None = None,\n    executor_port: int | None = None,\n    resource_port: int | None = None,\n    port_allocation_timeout: float = 10,\n    show_pull_progress: bool = True,\n):\n    self.tag = tag\n    self.binds = binds or {}\n    self.env = env or {}\n    self.show_pull_progress = show_pull_progress\n\n    self._docker = None\n    self._container = None\n    self._executor_port = executor_port\n    self._resource_port = resource_port\n    self._port_allocation_timeout = port_allocation_timeout\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.executor_port","title":"executor_port  <code>property</code>","text":"<pre><code>executor_port: int\n</code></pre> <p>The host port of the container's executor port. Either an application-defined <code>executor_port</code> via the constructor or a dynamically allocated random port.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container is not running and an application-defined port was not provided.</p>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.resource_port","title":"resource_port  <code>property</code>","text":"<pre><code>resource_port: int\n</code></pre> <p>The host port of the container's resource port. Either an application-defined <code>resource_port</code> via the constructor or a dynamically allocated random port.</p> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container is not running and an application-defined port was not provided.</p>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.init_firewall","title":"init_firewall  <code>async</code>","text":"<pre><code>init_firewall(\n    allowed_domains: list[str] | None = None,\n) -&gt; None\n</code></pre> <p>Initialize firewall rules to restrict internet access to a whitelist of allowed domains, IPv4 addresses, or CIDR ranges.</p> <p>Traffic policy inside the container after initialisation:</p> <ul> <li>DNS resolution (UDP/53) is always permitted so that the script itself can resolve   domains and regular runtime code can still perform look-ups.</li> <li>SSH (TCP/22) is permitted for interaction with the host.</li> <li>Loopback traffic is unrestricted.</li> <li>The host network (*/24 derived from the default gateway) is allowed bidirectionally.</li> <li>Bidirectional traffic on the ipybox executor (8888) and resource (8900) ports   is always allowed.</li> <li>Outbound traffic is allowed only to the specified whitelist entries.</li> </ul> <p>DNS failures when resolving an allowed domain yield a warning but do not stop the firewall initialization.</p> <p>A firewall can be initialized multiple times per container. Subsequent calls will clear previous firewall rules and enforce the new <code>allowed_domains</code> list.</p> <p>Parameters:</p> Name Type Description Default <code>allowed_domains</code> <code>list[str] | None</code> <p>List of domains, IP addresses, or CIDR ranges that should be reachable from the container. If None or empty, only essential services are allowed.</p> <code>None</code> <p>Raises:</p> Type Description <code>RuntimeError</code> <p>If the container is not running, firewall initialization fails, or if the container is running as root (ipybox images built with -r flag).</p> Source code in <code>ipybox/container.py</code> <pre><code>async def init_firewall(self, allowed_domains: list[str] | None = None) -&gt; None:\n    \"\"\"Initialize firewall rules to restrict internet access to a whitelist of\n    allowed domains, IPv4 addresses, or CIDR ranges.\n\n    Traffic policy inside the container after initialisation:\n\n    - DNS resolution (UDP/53) is always permitted so that the script itself can resolve\n      domains and regular runtime code can still perform look-ups.\n    - SSH (TCP/22) is permitted for interaction with the host.\n    - Loopback traffic is unrestricted.\n    - The host network (\\\\*/24 derived from the default gateway) is allowed bidirectionally.\n    - Bidirectional traffic on the ipybox *executor* (8888) and *resource* (8900) ports\n      is always allowed.\n    - Outbound traffic is allowed only to the specified whitelist entries.\n\n    DNS failures when resolving an allowed domain yield a warning but do not stop\n    the firewall initialization.\n\n    A firewall can be initialized multiple times per container. Subsequent calls will\n    clear previous firewall rules and enforce the new `allowed_domains` list.\n\n    Args:\n        allowed_domains: List of domains, IP addresses, or CIDR ranges that should be\n            reachable from the container. If None or empty, only essential services are\n            allowed.\n\n    Raises:\n        RuntimeError: If the container is not running, firewall initialization fails,\n            or if the container is running as root (ipybox images built with -r flag).\n    \"\"\"\n    if not self._container:\n        raise RuntimeError(\"Container not running\")\n\n    if allowed_domains is None:\n        allowed_domains = []\n\n    # Build command arguments\n    cmd_args = [\"/usr/local/bin/init-firewall.sh\"]\n    cmd_args.extend(allowed_domains)\n    cmd_args.extend([\"--executor-port\", str(8888), \"--resource-port\", str(8900)])\n\n    try:\n        # Execute firewall initialization script as root\n        exec_instance = await self._container.exec(\n            cmd=cmd_args,\n            stdout=True,\n            stderr=True,\n            tty=False,\n            user=\"root\",\n        )\n\n        output_chunks: list[bytes] = []\n        async with exec_instance.start(detach=False) as stream:\n            while True:\n                msg = await stream.read_out()\n                if msg is None:\n                    break\n\n                # Append both stdout (stream==1) and stderr (stream==2)\n                # data so we don't lose any diagnostic information.\n                if msg.data:\n                    output_chunks.append(msg.data)\n\n        output_text = b\"\".join(output_chunks).decode(errors=\"replace\")\n\n        # Check the exit status to ensure the firewall script completed successfully.\n        # If the script fails, raise an error with the exit code and the output text.\n        inspect_data = await exec_instance.inspect()\n        exit_code = inspect_data.get(\"ExitCode\")\n\n        if exit_code not in (0, None):\n            error_message = f\"init script returned exit code {exit_code}.\"\n            error_message = error_message + f\"\\n{output_text}\" if output_text else \"\"\n            raise RuntimeError(error_message)\n        else:\n            for line in output_text.splitlines():\n                logger.info(line)\n\n    except Exception as e:\n        raise RuntimeError(f\"Failed to initialize firewall: {str(e)}\") from e\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.kill","title":"kill  <code>async</code>","text":"<pre><code>kill()\n</code></pre> <p>Kills and removes the current code execution Docker container.</p> Source code in <code>ipybox/container.py</code> <pre><code>async def kill(self):\n    \"\"\"Kills and removes the current code execution Docker container.\"\"\"\n    if self._container:\n        await self._container.kill()\n\n    if self._docker:\n        await self._docker.close()\n</code></pre>"},{"location":"api/execution_container/#ipybox.container.ExecutionContainer.run","title":"run  <code>async</code>","text":"<pre><code>run()\n</code></pre> <p>Creates and starts a code execution Docker container.</p> Source code in <code>ipybox/container.py</code> <pre><code>async def run(self):\n    \"\"\"Creates and starts a code execution Docker container.\"\"\"\n    self._docker = Docker()\n    await self._run()\n</code></pre>"},{"location":"api/resource_client/","title":"ResourceClient","text":""},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient","title":"ResourceClient","text":"<pre><code>ResourceClient(\n    port: int,\n    host: str = \"localhost\",\n    connect_retries: int = 10,\n    connect_retry_interval: float = 1.0,\n)\n</code></pre> <p>Context manager for</p> <ul> <li>loading the source code of Python modules and generated MCP client functions   from an <code>ExecutionContainer</code>.</li> <li>generating Python client functions from MCP server tool metadata and storing   the generated sources in an <code>ExecutionContainer</code>.</li> </ul> <p>Parameters:</p> Name Type Description Default <code>port</code> <code>int</code> <p>Host port for the container's resource port</p> required <code>host</code> <code>str</code> <p>Hostname or IP address of the container's host</p> <code>'localhost'</code> <code>connect_retries</code> <code>int</code> <p>Number of connection retries.</p> <code>10</code> <code>connect_retry_interval</code> <code>float</code> <p>Delay between connection retries in seconds.</p> <code>1.0</code> Source code in <code>ipybox/resource/client.py</code> <pre><code>def __init__(\n    self,\n    port: int,\n    host: str = \"localhost\",\n    connect_retries: int = 10,\n    connect_retry_interval: float = 1.0,\n):\n    self.port = port\n    self.host = host\n    self._base_url = f\"http://{self.host}:{self.port}\"\n    self._session: aiohttp.ClientSession = None\n    self._connect_retries = connect_retries\n    self._connect_retry_interval = connect_retry_interval\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.delete_file","title":"delete_file  <code>async</code>","text":"<pre><code>delete_file(relpath: str) -&gt; None\n</code></pre> <p>Delete a file from the container.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory</p> required <p>Raises:</p> Type Description <code>HTTPError</code> <p>If the file doesn't exist or deletion fails</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def delete_file(self, relpath: str) -&gt; None:\n    \"\"\"Delete a file from the container.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory\n\n    Raises:\n        HTTPError: If the file doesn't exist or deletion fails\n    \"\"\"\n    url = f\"{self._base_url}/files/{relpath}\"\n    async with self._session.delete(url) as response:\n        response.raise_for_status()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.download_directory","title":"download_directory  <code>async</code>","text":"<pre><code>download_directory(relpath: str, local_path: Path) -&gt; None\n</code></pre> <p>Download a directory from the container as a tar archive.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory</p> required <code>local_path</code> <code>Path</code> <p>Local directory path to extract to</p> required <p>Raises:</p> Type Description <code>HTTPError</code> <p>If the directory doesn't exist or download fails</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def download_directory(self, relpath: str, local_path: Path) -&gt; None:\n    \"\"\"Download a directory from the container as a tar archive.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory\n        local_path: Local directory path to extract to\n\n    Raises:\n        HTTPError: If the directory doesn't exist or download fails\n    \"\"\"\n    # Create target directory\n    local_path.mkdir(parents=True, exist_ok=True)\n\n    url = f\"{self._base_url}/directories/{relpath}\"\n    async with self._session.get(url) as response:\n        response.raise_for_status()\n\n        # Download tar content\n        content = await response.read()\n\n        # Extract tar archive\n        with io.BytesIO(content) as tar_buffer:\n            with tarfile.open(fileobj=tar_buffer, mode=\"r:gz\") as tar:\n                # Extract all files\n                tar.extractall(path=local_path)\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.download_file","title":"download_file  <code>async</code>","text":"<pre><code>download_file(relpath: str, local_path: Path) -&gt; None\n</code></pre> <p>Download a file from the container.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory</p> required <code>local_path</code> <code>Path</code> <p>Local file path to save to</p> required <p>Raises:</p> Type Description <code>HTTPError</code> <p>If the file doesn't exist or download fails</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def download_file(self, relpath: str, local_path: Path) -&gt; None:\n    \"\"\"Download a file from the container.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory\n        local_path: Local file path to save to\n\n    Raises:\n        HTTPError: If the file doesn't exist or download fails\n    \"\"\"\n    # Create parent directories if needed\n    local_path.parent.mkdir(parents=True, exist_ok=True)\n\n    url = f\"{self._base_url}/files/{relpath}\"\n    async with self._session.get(url) as response:\n        response.raise_for_status()\n\n        # Stream content to file\n        async with aiofiles.open(local_path, mode=\"wb\") as f:\n            async for chunk in response.content.iter_chunked(1024 * 1024):  # 1MB chunks\n                await f.write(chunk)\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.generate_mcp_sources","title":"generate_mcp_sources  <code>async</code>","text":"<pre><code>generate_mcp_sources(\n    relpath: str,\n    server_name: str,\n    server_params: dict[str, Any],\n) -&gt; list[str]\n</code></pre> <p>Generate Python client functions for tools provided by an MCP server.</p> <p>One MCP client function is generated per MCP tool from its metadata. The generated function is stored in a module named <code>/app/{relpath}/{server_name}/{tool_name}.py</code>. Importing this module and calling the function invokes the corresponding MCP tool. This works for both <code>stdio</code> and <code>sse</code> based MCP servers. <code>stdio</code> based MCP servers are executed inside the container, <code>sse</code> based MCP servers are expected to run elsewhere.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory.</p> required <code>server_name</code> <code>str</code> <p>An application-defined name for the MCP server. Must be a valid Python module name.</p> required <code>server_params</code> <code>dict[str, Any]</code> <p>MCP server configuration. <code>stdio</code> server configurations must specify at least a <code>command</code> key, <code>sse</code> server configurations must specify at least a <code>url</code> key.</p> required <p>Returns:</p> Type Description <code>list[str]</code> <p>List of tool names provided by the MCP server. Tool names are sanitized to ensure they can be used as Python module names.</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def generate_mcp_sources(self, relpath: str, server_name: str, server_params: dict[str, Any]) -&gt; list[str]:\n    \"\"\"Generate Python client functions for tools provided by an MCP server.\n\n    One MCP client function is generated per MCP tool from its metadata. The generated function is stored in a\n    module named `/app/{relpath}/{server_name}/{tool_name}.py`. Importing this module and calling the function\n    invokes the corresponding MCP tool. This works for both `stdio` and `sse` based MCP servers. `stdio` based\n    MCP servers are executed inside the container, `sse` based MCP servers are expected to run elsewhere.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory.\n        server_name: An application-defined name for the MCP server. Must be a valid Python module name.\n        server_params: MCP server configuration. `stdio` server configurations must specify at least a `command`\n            key, `sse` server configurations must specify at least a `url` key.\n\n    Returns:\n        List of tool names provided by the MCP server. Tool names are sanitized to ensure they\n            can be used as Python module names.\n    \"\"\"\n    url = f\"{self._base_url}/mcp/{relpath}/{server_name}\"\n    async with self._session.put(url, json=server_params) as response:\n        response.raise_for_status()\n        return await response.json()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.get_mcp_sources","title":"get_mcp_sources  <code>async</code>","text":"<pre><code>get_mcp_sources(\n    relpath: str, server_name: str\n) -&gt; dict[str, str]\n</code></pre> <p>Get the source code of generated MCP client functions for given MCP <code>server_name</code>.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory</p> required <code>server_name</code> <code>str</code> <p>Application-defined name of an MCP server</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Source code of generated MCP client functions. Keys are tool names, values are generated sources.</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def get_mcp_sources(self, relpath: str, server_name: str) -&gt; dict[str, str]:\n    \"\"\"Get the source code of generated MCP client functions for given MCP `server_name`.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory\n        server_name: Application-defined name of an MCP server\n\n    Returns:\n        Source code of generated MCP client functions. Keys are tool names, values are generated sources.\n    \"\"\"\n    url = f\"{self._base_url}/mcp/{relpath}\"\n    async with self._session.get(url, params={\"server_name\": server_name}) as response:\n        response.raise_for_status()\n        return await response.json()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.get_module_sources","title":"get_module_sources  <code>async</code>","text":"<pre><code>get_module_sources(\n    module_names: list[str],\n) -&gt; dict[str, str]\n</code></pre> <p>Get the source code of Python modules on the container's Python path.</p> <p>Parameters:</p> Name Type Description Default <code>module_names</code> <code>list[str]</code> <p>A list of Python module names.</p> required <p>Returns:</p> Type Description <code>dict[str, str]</code> <p>Source code of Python modules. Keys are module names, values are module sources.</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def get_module_sources(self, module_names: list[str]) -&gt; dict[str, str]:\n    \"\"\"Get the source code of Python modules on the container's Python path.\n\n    Args:\n        module_names: A list of Python module names.\n\n    Returns:\n        Source code of Python modules. Keys are module names, values are module sources.\n    \"\"\"\n    url = f\"{self._base_url}/modules\"\n    async with self._session.get(url, params={\"q\": module_names}) as response:\n        response.raise_for_status()\n        return await response.json()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.upload_directory","title":"upload_directory  <code>async</code>","text":"<pre><code>upload_directory(relpath: str, local_path: Path) -&gt; None\n</code></pre> <p>Upload a directory to the container as a tar archive.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory</p> required <code>local_path</code> <code>Path</code> <p>Local directory path to upload</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the local directory doesn't exist</p> <code>HTTPError</code> <p>If the upload fails</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def upload_directory(self, relpath: str, local_path: Path) -&gt; None:\n    \"\"\"Upload a directory to the container as a tar archive.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory\n        local_path: Local directory path to upload\n\n    Raises:\n        FileNotFoundError: If the local directory doesn't exist\n        HTTPError: If the upload fails\n    \"\"\"\n    if not local_path.exists() or not local_path.is_dir():\n        raise FileNotFoundError(f\"Local directory not found: {local_path}\")\n\n    # Create tar archive in memory\n    tar_buffer = io.BytesIO()\n    with tarfile.open(fileobj=tar_buffer, mode=\"w:gz\") as tar:\n        # Add directory contents to archive\n        for item in local_path.rglob(\"*\"):\n            if item.is_file():\n                # Calculate relative path for archive\n                arcname = item.relative_to(local_path)\n                tar.add(item, arcname=str(arcname))\n\n    # Upload tar archive\n    tar_buffer.seek(0)\n    url = f\"{self._base_url}/directories/{relpath}\"\n    headers = {\"Content-Type\": \"application/x-gzip\"}\n    async with self._session.post(url, data=tar_buffer.getvalue(), headers=headers) as response:\n        response.raise_for_status()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ResourceClient.upload_file","title":"upload_file  <code>async</code>","text":"<pre><code>upload_file(relpath: str, local_path: Path) -&gt; None\n</code></pre> <p>Upload a file to the container.</p> <p>Parameters:</p> Name Type Description Default <code>relpath</code> <code>str</code> <p>Path relative to the container's <code>/app</code> directory</p> required <code>local_path</code> <code>Path</code> <p>Local file path to upload</p> required <p>Raises:</p> Type Description <code>FileNotFoundError</code> <p>If the local file doesn't exist</p> <code>HTTPError</code> <p>If the upload fails</p> Source code in <code>ipybox/resource/client.py</code> <pre><code>async def upload_file(self, relpath: str, local_path: Path) -&gt; None:\n    \"\"\"Upload a file to the container.\n\n    Args:\n        relpath: Path relative to the container's `/app` directory\n        local_path: Local file path to upload\n\n    Raises:\n        FileNotFoundError: If the local file doesn't exist\n        HTTPError: If the upload fails\n    \"\"\"\n    if not local_path.exists() or not local_path.is_file():\n        raise FileNotFoundError(f\"Local file not found: {local_path}\")\n\n    # Determine MIME type\n    mime_type, _ = mimetypes.guess_type(str(local_path))\n    headers = {\"Content-Type\": mime_type} if mime_type else {}\n\n    # Read and upload file\n    async with aiofiles.open(local_path, mode=\"rb\") as f:\n        content = await f.read()\n\n    url = f\"{self._base_url}/files/{relpath}\"\n    async with self._session.post(url, data=content, headers=headers) as response:\n        response.raise_for_status()\n</code></pre>"},{"location":"api/resource_client/#ipybox.resource.client.ConnectionError","title":"ConnectionError","text":"<p>               Bases: <code>Exception</code></p> <p>Raised when a connection to a resource server cannot be established.</p>"}]}